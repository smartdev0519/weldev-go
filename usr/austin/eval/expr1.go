package eval

// generated code

import (
	"bignum";
	"log";
)

/*
 * Operator generators
 * Everything below here is MACHINE GENERATED by gen.py genOps
 */

func (a *expr) genConstant(v Value) {
	switch _ := a.t.lit().(type) {
	case *boolType:
		val := v.(BoolValue).Get();
		a.eval = func(f *Frame) bool { return val };
	case *uintType:
		val := v.(UintValue).Get();
		a.eval = func(f *Frame) uint64 { return val };
	case *intType:
		val := v.(IntValue).Get();
		a.eval = func(f *Frame) int64 { return val };
	case *idealIntType:
		val := v.(IdealIntValue).Get();
		a.eval = func() *bignum.Integer { return val };
	case *floatType:
		val := v.(FloatValue).Get();
		a.eval = func(f *Frame) float64 { return val };
	case *idealFloatType:
		val := v.(IdealFloatValue).Get();
		a.eval = func() *bignum.Rational { return val };
	case *stringType:
		val := v.(StringValue).Get();
		a.eval = func(f *Frame) string { return val };
	case *ArrayType:
		val := v.(ArrayValue).Get();
		a.eval = func(f *Frame) ArrayValue { return val };
	case *StructType:
		val := v.(StructValue).Get();
		a.eval = func(f *Frame) StructValue { return val };
	case *PtrType:
		val := v.(PtrValue).Get();
		a.eval = func(f *Frame) Value { return val };
	case *FuncType:
		val := v.(FuncValue).Get();
		a.eval = func(f *Frame) Func { return val };
	case *SliceType:
		val := v.(SliceValue).Get();
		a.eval = func(f *Frame) Slice { return val };
	case *MapType:
		val := v.(MapValue).Get();
		a.eval = func(f *Frame) Map { return val };
	default:
		log.Crashf("unexpected constant type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genIdentOp(level int, index int) {
	a.evalAddr = func(f *Frame) Value { return f.Get(level, index) };
	switch _ := a.t.lit().(type) {
	case *boolType:
		a.eval = func(f *Frame) bool { return f.Get(level, index).(BoolValue).Get() };
	case *uintType:
		a.eval = func(f *Frame) uint64 { return f.Get(level, index).(UintValue).Get() };
	case *intType:
		a.eval = func(f *Frame) int64 { return f.Get(level, index).(IntValue).Get() };
	case *floatType:
		a.eval = func(f *Frame) float64 { return f.Get(level, index).(FloatValue).Get() };
	case *stringType:
		a.eval = func(f *Frame) string { return f.Get(level, index).(StringValue).Get() };
	case *ArrayType:
		a.eval = func(f *Frame) ArrayValue { return f.Get(level, index).(ArrayValue).Get() };
	case *StructType:
		a.eval = func(f *Frame) StructValue { return f.Get(level, index).(StructValue).Get() };
	case *PtrType:
		a.eval = func(f *Frame) Value { return f.Get(level, index).(PtrValue).Get() };
	case *FuncType:
		a.eval = func(f *Frame) Func { return f.Get(level, index).(FuncValue).Get() };
	case *SliceType:
		a.eval = func(f *Frame) Slice { return f.Get(level, index).(SliceValue).Get() };
	case *MapType:
		a.eval = func(f *Frame) Map { return f.Get(level, index).(MapValue).Get() };
	default:
		log.Crashf("unexpected identifier type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genFuncCall(call func(f *Frame) []Value) {
	a.exec = func(f *Frame) { call(f) };
	switch _ := a.t.lit().(type) {
	case *boolType:
		a.eval = func(f *Frame) bool { return call(f)[0].(BoolValue).Get() };
	case *uintType:
		a.eval = func(f *Frame) uint64 { return call(f)[0].(UintValue).Get() };
	case *intType:
		a.eval = func(f *Frame) int64 { return call(f)[0].(IntValue).Get() };
	case *floatType:
		a.eval = func(f *Frame) float64 { return call(f)[0].(FloatValue).Get() };
	case *stringType:
		a.eval = func(f *Frame) string { return call(f)[0].(StringValue).Get() };
	case *ArrayType:
		a.eval = func(f *Frame) ArrayValue { return call(f)[0].(ArrayValue).Get() };
	case *StructType:
		a.eval = func(f *Frame) StructValue { return call(f)[0].(StructValue).Get() };
	case *PtrType:
		a.eval = func(f *Frame) Value { return call(f)[0].(PtrValue).Get() };
	case *FuncType:
		a.eval = func(f *Frame) Func { return call(f)[0].(FuncValue).Get() };
	case *SliceType:
		a.eval = func(f *Frame) Slice { return call(f)[0].(SliceValue).Get() };
	case *MapType:
		a.eval = func(f *Frame) Map { return call(f)[0].(MapValue).Get() };
	case *MultiType:
		a.eval = func(f *Frame) []Value { return call(f) };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genValue(vf func(*Frame) Value) {
	a.evalAddr = vf;
	switch _ := a.t.lit().(type) {
	case *boolType:
		a.eval = func(f *Frame) bool { return vf(f).(BoolValue).Get() };
	case *uintType:
		a.eval = func(f *Frame) uint64 { return vf(f).(UintValue).Get() };
	case *intType:
		a.eval = func(f *Frame) int64 { return vf(f).(IntValue).Get() };
	case *floatType:
		a.eval = func(f *Frame) float64 { return vf(f).(FloatValue).Get() };
	case *stringType:
		a.eval = func(f *Frame) string { return vf(f).(StringValue).Get() };
	case *ArrayType:
		a.eval = func(f *Frame) ArrayValue { return vf(f).(ArrayValue).Get() };
	case *StructType:
		a.eval = func(f *Frame) StructValue { return vf(f).(StructValue).Get() };
	case *PtrType:
		a.eval = func(f *Frame) Value { return vf(f).(PtrValue).Get() };
	case *FuncType:
		a.eval = func(f *Frame) Func { return vf(f).(FuncValue).Get() };
	case *SliceType:
		a.eval = func(f *Frame) Slice { return vf(f).(SliceValue).Get() };
	case *MapType:
		a.eval = func(f *Frame) Map { return vf(f).(MapValue).Get() };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genUnaryOpNeg(v *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		vf := v.asUint();
		a.eval = func(f *Frame) uint64 { return -vf(f) };
	case *intType:
		vf := v.asInt();
		a.eval = func(f *Frame) int64 { return -vf(f) };
	case *idealIntType:
		vf := v.asIdealInt();
		val := vf().Neg();
		a.eval = func() *bignum.Integer { return val };
	case *floatType:
		vf := v.asFloat();
		a.eval = func(f *Frame) float64 { return -vf(f) };
	case *idealFloatType:
		vf := v.asIdealFloat();
		val := vf().Neg();
		a.eval = func() *bignum.Rational { return val };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genUnaryOpNot(v *expr) {
	switch _ := a.t.lit().(type) {
	case *boolType:
		vf := v.asBool();
		a.eval = func(f *Frame) bool { return !vf(f) };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genUnaryOpXor(v *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		vf := v.asUint();
		a.eval = func(f *Frame) uint64 { return ^vf(f) };
	case *intType:
		vf := v.asInt();
		a.eval = func(f *Frame) int64 { return ^vf(f) };
	case *idealIntType:
		vf := v.asIdealInt();
		val := vf().Neg().Sub(bignum.Int(1));
		a.eval = func() *bignum.Integer { return val };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpAdd(l, r *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { return lf(f) + rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { return lf(f) + rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Add(rf());
		a.eval = func() *bignum.Integer { return val };
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) float64 { return lf(f) + rf(f) };
	case *idealFloatType:
		lf := l.asIdealFloat();
		rf := r.asIdealFloat();
		val := lf().Add(rf());
		a.eval = func() *bignum.Rational { return val };
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) string { return lf(f) + rf(f) };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpSub(l, r *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { return lf(f) - rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { return lf(f) - rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Sub(rf());
		a.eval = func() *bignum.Integer { return val };
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) float64 { return lf(f) - rf(f) };
	case *idealFloatType:
		lf := l.asIdealFloat();
		rf := r.asIdealFloat();
		val := lf().Sub(rf());
		a.eval = func() *bignum.Rational { return val };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpMul(l, r *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { return lf(f) * rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { return lf(f) * rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Mul(rf());
		a.eval = func() *bignum.Integer { return val };
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) float64 { return lf(f) * rf(f) };
	case *idealFloatType:
		lf := l.asIdealFloat();
		rf := r.asIdealFloat();
		val := lf().Mul(rf());
		a.eval = func() *bignum.Rational { return val };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpQuo(l, r *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); if r == 0 { Abort(DivByZero{}) }; return l / r };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); if r == 0 { Abort(DivByZero{}) }; return l / r };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Quo(rf());
		a.eval = func() *bignum.Integer { return val };
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) float64 { l, r := lf(f), rf(f); if r == 0 { Abort(DivByZero{}) }; return l / r };
	case *idealFloatType:
		lf := l.asIdealFloat();
		rf := r.asIdealFloat();
		val := lf().Quo(rf());
		a.eval = func() *bignum.Rational { return val };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpRem(l, r *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); if r == 0 { Abort(DivByZero{}) }; return l % r };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); if r == 0 { Abort(DivByZero{}) }; return l % r };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Rem(rf());
		a.eval = func() *bignum.Integer { return val };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpAnd(l, r *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { return lf(f) & rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { return lf(f) & rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().And(rf());
		a.eval = func() *bignum.Integer { return val };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpOr(l, r *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { return lf(f) | rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { return lf(f) | rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Or(rf());
		a.eval = func() *bignum.Integer { return val };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpXor(l, r *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { return lf(f) ^ rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { return lf(f) ^ rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Xor(rf());
		a.eval = func() *bignum.Integer { return val };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpAndNot(l, r *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { return lf(f) &^ rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { return lf(f) &^ rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().AndNot(rf());
		a.eval = func() *bignum.Integer { return val };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpShl(l, r *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { return lf(f) << rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asUint();
		a.eval = func(f *Frame) int64 { return lf(f) << rf(f) };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpShr(l, r *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { return lf(f) >> rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asUint();
		a.eval = func(f *Frame) int64 { return lf(f) >> rf(f) };
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpLss(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { return lf(f) < rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { return lf(f) < rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Cmp(rf()) < 0;
		a.eval = func(f *Frame) bool { return val };
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { return lf(f) < rf(f) };
	case *idealFloatType:
		lf := l.asIdealFloat();
		rf := r.asIdealFloat();
		val := lf().Cmp(rf()) < 0;
		a.eval = func(f *Frame) bool { return val };
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { return lf(f) < rf(f) };
	default:
		log.Crashf("unexpected left operand type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpGtr(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { return lf(f) > rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { return lf(f) > rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Cmp(rf()) > 0;
		a.eval = func(f *Frame) bool { return val };
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { return lf(f) > rf(f) };
	case *idealFloatType:
		lf := l.asIdealFloat();
		rf := r.asIdealFloat();
		val := lf().Cmp(rf()) > 0;
		a.eval = func(f *Frame) bool { return val };
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { return lf(f) > rf(f) };
	default:
		log.Crashf("unexpected left operand type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpLeq(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { return lf(f) <= rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { return lf(f) <= rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Cmp(rf()) <= 0;
		a.eval = func(f *Frame) bool { return val };
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { return lf(f) <= rf(f) };
	case *idealFloatType:
		lf := l.asIdealFloat();
		rf := r.asIdealFloat();
		val := lf().Cmp(rf()) <= 0;
		a.eval = func(f *Frame) bool { return val };
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { return lf(f) <= rf(f) };
	default:
		log.Crashf("unexpected left operand type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpGeq(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { return lf(f) >= rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { return lf(f) >= rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Cmp(rf()) >= 0;
		a.eval = func(f *Frame) bool { return val };
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { return lf(f) >= rf(f) };
	case *idealFloatType:
		lf := l.asIdealFloat();
		rf := r.asIdealFloat();
		val := lf().Cmp(rf()) >= 0;
		a.eval = func(f *Frame) bool { return val };
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { return lf(f) >= rf(f) };
	default:
		log.Crashf("unexpected left operand type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpEql(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *boolType:
		lf := l.asBool();
		rf := r.asBool();
		a.eval = func(f *Frame) bool { return lf(f) == rf(f) };
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { return lf(f) == rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { return lf(f) == rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Cmp(rf()) == 0;
		a.eval = func(f *Frame) bool { return val };
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { return lf(f) == rf(f) };
	case *idealFloatType:
		lf := l.asIdealFloat();
		rf := r.asIdealFloat();
		val := lf().Cmp(rf()) == 0;
		a.eval = func(f *Frame) bool { return val };
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { return lf(f) == rf(f) };
	case *PtrType:
		lf := l.asPtr();
		rf := r.asPtr();
		a.eval = func(f *Frame) bool { return lf(f) == rf(f) };
	case *FuncType:
		lf := l.asFunc();
		rf := r.asFunc();
		a.eval = func(f *Frame) bool { return lf(f) == rf(f) };
	case *MapType:
		lf := l.asMap();
		rf := r.asMap();
		a.eval = func(f *Frame) bool { return lf(f) == rf(f) };
	default:
		log.Crashf("unexpected left operand type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpNeq(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *boolType:
		lf := l.asBool();
		rf := r.asBool();
		a.eval = func(f *Frame) bool { return lf(f) != rf(f) };
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { return lf(f) != rf(f) };
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { return lf(f) != rf(f) };
	case *idealIntType:
		lf := l.asIdealInt();
		rf := r.asIdealInt();
		val := lf().Cmp(rf()) != 0;
		a.eval = func(f *Frame) bool { return val };
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { return lf(f) != rf(f) };
	case *idealFloatType:
		lf := l.asIdealFloat();
		rf := r.asIdealFloat();
		val := lf().Cmp(rf()) != 0;
		a.eval = func(f *Frame) bool { return val };
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { return lf(f) != rf(f) };
	case *PtrType:
		lf := l.asPtr();
		rf := r.asPtr();
		a.eval = func(f *Frame) bool { return lf(f) != rf(f) };
	case *FuncType:
		lf := l.asFunc();
		rf := r.asFunc();
		a.eval = func(f *Frame) bool { return lf(f) != rf(f) };
	case *MapType:
		lf := l.asMap();
		rf := r.asMap();
		a.eval = func(f *Frame) bool { return lf(f) != rf(f) };
	default:
		log.Crashf("unexpected left operand type %v at %v", l.t, a.pos);
	}
}

func genAssign(lt Type, r *expr) (func(lv Value, f *Frame)) {
	switch _ := lt.lit().(type) {
	case *boolType:
		rf := r.asBool();
		return func(lv Value, f *Frame) { lv.(BoolValue).Set(rf(f)) };
	case *uintType:
		rf := r.asUint();
		return func(lv Value, f *Frame) { lv.(UintValue).Set(rf(f)) };
	case *intType:
		rf := r.asInt();
		return func(lv Value, f *Frame) { lv.(IntValue).Set(rf(f)) };
	case *floatType:
		rf := r.asFloat();
		return func(lv Value, f *Frame) { lv.(FloatValue).Set(rf(f)) };
	case *stringType:
		rf := r.asString();
		return func(lv Value, f *Frame) { lv.(StringValue).Set(rf(f)) };
	case *ArrayType:
		rf := r.asArray();
		return func(lv Value, f *Frame) { lv.Assign(rf(f)) };
	case *StructType:
		rf := r.asStruct();
		return func(lv Value, f *Frame) { lv.Assign(rf(f)) };
	case *PtrType:
		rf := r.asPtr();
		return func(lv Value, f *Frame) { lv.(PtrValue).Set(rf(f)) };
	case *FuncType:
		rf := r.asFunc();
		return func(lv Value, f *Frame) { lv.(FuncValue).Set(rf(f)) };
	case *SliceType:
		rf := r.asSlice();
		return func(lv Value, f *Frame) { lv.(SliceValue).Set(rf(f)) };
	case *MapType:
		rf := r.asMap();
		return func(lv Value, f *Frame) { lv.(MapValue).Set(rf(f)) };
	default:
		log.Crashf("unexpected left operand type %v at %v", lt, r.pos);
	}
	panic();
}
