
// This file is machine generated by gen.go.
// 6g gen.go && 6l gen.6 && 6.out >expr1.go

package eval

import (
	"bignum";
	"log";
)

/*
 * "As" functions.  These retrieve evaluator functions from an
 * expr, panicking if the requested evaluator has the wrong type.
 */
func (a *expr) asBool() (func(*Frame) bool) {
	return a.eval.(func(*Frame)(bool))
}
func (a *expr) asUint() (func(*Frame) uint64) {
	return a.eval.(func(*Frame)(uint64))
}
func (a *expr) asInt() (func(*Frame) int64) {
	return a.eval.(func(*Frame)(int64))
}
func (a *expr) asIdealInt() (func() *bignum.Integer) {
	return a.eval.(func()(*bignum.Integer))
}
func (a *expr) asFloat() (func(*Frame) float64) {
	return a.eval.(func(*Frame)(float64))
}
func (a *expr) asIdealFloat() (func() *bignum.Rational) {
	return a.eval.(func()(*bignum.Rational))
}
func (a *expr) asString() (func(*Frame) string) {
	return a.eval.(func(*Frame)(string))
}
func (a *expr) asArray() (func(*Frame) ArrayValue) {
	return a.eval.(func(*Frame)(ArrayValue))
}
func (a *expr) asStruct() (func(*Frame) StructValue) {
	return a.eval.(func(*Frame)(StructValue))
}
func (a *expr) asPtr() (func(*Frame) Value) {
	return a.eval.(func(*Frame)(Value))
}
func (a *expr) asFunc() (func(*Frame) Func) {
	return a.eval.(func(*Frame)(Func))
}
func (a *expr) asSlice() (func(*Frame) Slice) {
	return a.eval.(func(*Frame)(Slice))
}
func (a *expr) asMap() (func(*Frame) Map) {
	return a.eval.(func(*Frame)(Map))
}
func (a *expr) asMulti() (func(*Frame) []Value) {
	return a.eval.(func(*Frame)[]Value)
}

func (a *expr) asInterface() (func(*Frame) interface{}) {
	switch sf := a.eval.(type) {
	case func(*Frame)bool:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)uint64:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)int64:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)*bignum.Integer:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)float64:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)*bignum.Rational:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)string:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)ArrayValue:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)StructValue:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)Value:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)Func:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)Slice:
		return func(f *Frame) interface{} { return sf(f) }
	case func(*Frame)Map:
		return func(f *Frame) interface{} { return sf(f) }
	default:
		log.Crashf("unexpected expression node type %T at %v", a.eval, a.pos);
	}
	panic();
}

/*
 * Operator generators.
 */

func (a *expr) genConstant(v Value) {
	switch _ := a.t.lit().(type) {
	case *boolType:
		val := v.(BoolValue).Get();
		a.eval = func(f *Frame) bool { return val }
	case *uintType:
		val := v.(UintValue).Get();
		a.eval = func(f *Frame) uint64 { return val }
	case *intType:
		val := v.(IntValue).Get();
		a.eval = func(f *Frame) int64 { return val }
	case *idealIntType:
		val := v.(IdealIntValue).Get();
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		val := v.(FloatValue).Get();
		a.eval = func(f *Frame) float64 { return val }
	case *idealFloatType:
		val := v.(IdealFloatValue).Get();
		a.eval = func() *bignum.Rational { return val }
	case *stringType:
		val := v.(StringValue).Get();
		a.eval = func(f *Frame) string { return val }
	case *ArrayType:
		val := v.(ArrayValue).Get();
		a.eval = func(f *Frame) ArrayValue { return val }
	case *StructType:
		val := v.(StructValue).Get();
		a.eval = func(f *Frame) StructValue { return val }
	case *PtrType:
		val := v.(PtrValue).Get();
		a.eval = func(f *Frame) Value { return val }
	case *FuncType:
		val := v.(FuncValue).Get();
		a.eval = func(f *Frame) Func { return val }
	case *SliceType:
		val := v.(SliceValue).Get();
		a.eval = func(f *Frame) Slice { return val }
	case *MapType:
		val := v.(MapValue).Get();
		a.eval = func(f *Frame) Map { return val }
	default:
		log.Crashf("unexpected constant type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genIdentOp(level, index int) {
	a.evalAddr = func(f *Frame) Value { return f.Get(level, index) };
	switch _ := a.t.lit().(type) {
	case *boolType:
		a.eval = func(f *Frame) bool { return f.Get(level, index).(BoolValue).Get() }
	case *uintType:
		a.eval = func(f *Frame) uint64 { return f.Get(level, index).(UintValue).Get() }
	case *intType:
		a.eval = func(f *Frame) int64 { return f.Get(level, index).(IntValue).Get() }
	case *floatType:
		a.eval = func(f *Frame) float64 { return f.Get(level, index).(FloatValue).Get() }
	case *stringType:
		a.eval = func(f *Frame) string { return f.Get(level, index).(StringValue).Get() }
	case *ArrayType:
		a.eval = func(f *Frame) ArrayValue { return f.Get(level, index).(ArrayValue).Get() }
	case *StructType:
		a.eval = func(f *Frame) StructValue { return f.Get(level, index).(StructValue).Get() }
	case *PtrType:
		a.eval = func(f *Frame) Value { return f.Get(level, index).(PtrValue).Get() }
	case *FuncType:
		a.eval = func(f *Frame) Func { return f.Get(level, index).(FuncValue).Get() }
	case *SliceType:
		a.eval = func(f *Frame) Slice { return f.Get(level, index).(SliceValue).Get() }
	case *MapType:
		a.eval = func(f *Frame) Map { return f.Get(level, index).(MapValue).Get() }
	default:
		log.Crashf("unexpected identifier type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genFuncCall(call func(f *Frame) []Value) {
	a.exec = func(f *Frame) { call(f)};
	switch _ := a.t.lit().(type) {
	case *boolType:
		a.eval = func(f *Frame) bool { return call(f)[0].(BoolValue).Get() }
	case *uintType:
		a.eval = func(f *Frame) uint64 { return call(f)[0].(UintValue).Get() }
	case *intType:
		a.eval = func(f *Frame) int64 { return call(f)[0].(IntValue).Get() }
	case *floatType:
		a.eval = func(f *Frame) float64 { return call(f)[0].(FloatValue).Get() }
	case *stringType:
		a.eval = func(f *Frame) string { return call(f)[0].(StringValue).Get() }
	case *ArrayType:
		a.eval = func(f *Frame) ArrayValue { return call(f)[0].(ArrayValue).Get() }
	case *StructType:
		a.eval = func(f *Frame) StructValue { return call(f)[0].(StructValue).Get() }
	case *PtrType:
		a.eval = func(f *Frame) Value { return call(f)[0].(PtrValue).Get() }
	case *FuncType:
		a.eval = func(f *Frame) Func { return call(f)[0].(FuncValue).Get() }
	case *SliceType:
		a.eval = func(f *Frame) Slice { return call(f)[0].(SliceValue).Get() }
	case *MapType:
		a.eval = func(f *Frame) Map { return call(f)[0].(MapValue).Get() }
	case *MultiType:
		a.eval = func(f *Frame) []Value { return call(f) }
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genValue(vf func(*Frame) Value) {
	a.evalAddr = vf;
	switch _ := a.t.lit().(type) {
	case *boolType:
		a.eval = func(f *Frame) bool { return vf(f).(BoolValue).Get() }
	case *uintType:
		a.eval = func(f *Frame) uint64 { return vf(f).(UintValue).Get() }
	case *intType:
		a.eval = func(f *Frame) int64 { return vf(f).(IntValue).Get() }
	case *floatType:
		a.eval = func(f *Frame) float64 { return vf(f).(FloatValue).Get() }
	case *stringType:
		a.eval = func(f *Frame) string { return vf(f).(StringValue).Get() }
	case *ArrayType:
		a.eval = func(f *Frame) ArrayValue { return vf(f).(ArrayValue).Get() }
	case *StructType:
		a.eval = func(f *Frame) StructValue { return vf(f).(StructValue).Get() }
	case *PtrType:
		a.eval = func(f *Frame) Value { return vf(f).(PtrValue).Get() }
	case *FuncType:
		a.eval = func(f *Frame) Func { return vf(f).(FuncValue).Get() }
	case *SliceType:
		a.eval = func(f *Frame) Slice { return vf(f).(SliceValue).Get() }
	case *MapType:
		a.eval = func(f *Frame) Map { return vf(f).(MapValue).Get() }
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genUnaryOpNeg(v *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		vf := v.asUint();
		a.eval = func(f *Frame) uint64 { v := vf(f); return -v }
	case *intType:
		vf := v.asInt();
		a.eval = func(f *Frame) int64 { v := vf(f); return -v }
	case *idealIntType:
		v := v.asIdealInt()();
		val := v.Neg();
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		vf := v.asFloat();
		a.eval = func(f *Frame) float64 { v := vf(f); return -v }
	case *idealFloatType:
		v := v.asIdealFloat()();
		val := v.Neg();
		a.eval = func() *bignum.Rational { return val }
	default:
		log.Crashf("unexpected type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genUnaryOpNot(v *expr) {
	switch _ := a.t.lit().(type) {
	case *boolType:
		vf := v.asBool();
		a.eval = func(f *Frame) bool { v := vf(f); return !v }
	default:
		log.Crashf("unexpected type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genUnaryOpXor(v *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		vf := v.asUint();
		a.eval = func(f *Frame) uint64 { v := vf(f); return ^v }
	case *intType:
		vf := v.asInt();
		a.eval = func(f *Frame) int64 { v := vf(f); return ^v }
	case *idealIntType:
		v := v.asIdealInt()();
		val := v.Neg().Sub(bignum.Int(1));
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpAdd(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); return l + r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); return l + r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Add(r);
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) float64 { l, r := lf(f), rf(f); return l + r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Add(r);
		a.eval = func() *bignum.Rational { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) string { l, r := lf(f), rf(f); return l + r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpSub(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); return l - r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); return l - r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Sub(r);
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) float64 { l, r := lf(f), rf(f); return l - r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Sub(r);
		a.eval = func() *bignum.Rational { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpMul(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); return l * r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); return l * r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Mul(r);
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) float64 { l, r := lf(f), rf(f); return l * r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Mul(r);
		a.eval = func() *bignum.Rational { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpQuo(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); if r == 0 { Abort(DivByZero{}) } return l / r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); if r == 0 { Abort(DivByZero{}) } return l / r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Quo(r);
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) float64 { l, r := lf(f), rf(f); if r == 0 { Abort(DivByZero{}) } return l / r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Quo(r);
		a.eval = func() *bignum.Rational { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpRem(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); if r == 0 { Abort(DivByZero{}) } return l % r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); if r == 0 { Abort(DivByZero{}) } return l % r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Rem(r);
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpAnd(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); return l & r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); return l & r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.And(r);
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpOr(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); return l | r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); return l | r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Or(r);
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpXor(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); return l ^ r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); return l ^ r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Xor(r);
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpAndNot(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); return l &^ r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); return l &^ r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.AndNot(r);
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpShl(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); return l << r }
	case *intType:
		lf := l.asInt();
		rf := r.asUint();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); return l << r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpShr(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) uint64 { l, r := lf(f), rf(f); return l >> r }
	case *intType:
		lf := l.asInt();
		rf := r.asUint();
		a.eval = func(f *Frame) int64 { l, r := lf(f), rf(f); return l >> r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpLss(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l < r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l < r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) < 0;
		a.eval = func(f *Frame) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l < r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) < 0;
		a.eval = func(f *Frame) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l < r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpGtr(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l > r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l > r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) > 0;
		a.eval = func(f *Frame) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l > r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) > 0;
		a.eval = func(f *Frame) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l > r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpLeq(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l <= r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l <= r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) <= 0;
		a.eval = func(f *Frame) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l <= r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) <= 0;
		a.eval = func(f *Frame) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l <= r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpGeq(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l >= r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l >= r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) >= 0;
		a.eval = func(f *Frame) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l >= r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) >= 0;
		a.eval = func(f *Frame) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l >= r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpEql(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *boolType:
		lf := l.asBool();
		rf := r.asBool();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l == r }
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l == r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l == r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) == 0;
		a.eval = func(f *Frame) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l == r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) == 0;
		a.eval = func(f *Frame) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l == r }
	case *PtrType:
		lf := l.asPtr();
		rf := r.asPtr();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l == r }
	case *FuncType:
		lf := l.asFunc();
		rf := r.asFunc();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l == r }
	case *MapType:
		lf := l.asMap();
		rf := r.asMap();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l == r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpNeq(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *boolType:
		lf := l.asBool();
		rf := r.asBool();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l != r }
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l != r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l != r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) != 0;
		a.eval = func(f *Frame) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l != r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) != 0;
		a.eval = func(f *Frame) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l != r }
	case *PtrType:
		lf := l.asPtr();
		rf := r.asPtr();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l != r }
	case *FuncType:
		lf := l.asFunc();
		rf := r.asFunc();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l != r }
	case *MapType:
		lf := l.asMap();
		rf := r.asMap();
		a.eval = func(f *Frame) bool { l, r := lf(f), rf(f); return l != r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func genAssign(lt Type, r *expr) (func(lv Value, f *Frame)) {
	switch _ := lt.lit().(type) {
	case *boolType:
		rf := r.asBool();
		return func(lv Value, f *Frame) { lv.(BoolValue).Set(rf(f)) }
	case *uintType:
		rf := r.asUint();
		return func(lv Value, f *Frame) { lv.(UintValue).Set(rf(f)) }
	case *intType:
		rf := r.asInt();
		return func(lv Value, f *Frame) { lv.(IntValue).Set(rf(f)) }
	case *floatType:
		rf := r.asFloat();
		return func(lv Value, f *Frame) { lv.(FloatValue).Set(rf(f)) }
	case *stringType:
		rf := r.asString();
		return func(lv Value, f *Frame) { lv.(StringValue).Set(rf(f)) }
	case *ArrayType:
		rf := r.asArray();
		return func(lv Value, f *Frame) { lv.Assign(rf(f)) }
	case *StructType:
		rf := r.asStruct();
		return func(lv Value, f *Frame) { lv.Assign(rf(f)) }
	case *PtrType:
		rf := r.asPtr();
		return func(lv Value, f *Frame) { lv.(PtrValue).Set(rf(f)) }
	case *FuncType:
		rf := r.asFunc();
		return func(lv Value, f *Frame) { lv.(FuncValue).Set(rf(f)) }
	case *SliceType:
		rf := r.asSlice();
		return func(lv Value, f *Frame) { lv.(SliceValue).Set(rf(f)) }
	case *MapType:
		rf := r.asMap();
		return func(lv Value, f *Frame) { lv.(MapValue).Set(rf(f)) }
	default:
		log.Crashf("unexpected left operand type %v at %v", lt, r.pos);
	}
	panic();
}
