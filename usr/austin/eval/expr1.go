
// This file is machine generated by gen.go.
// 6g gen.go && 6l gen.6 && ./6.out >expr1.go

package eval

import (
	"bignum";
	"log";
)

/*
 * "As" functions.  These retrieve evaluator functions from an
 * expr, panicking if the requested evaluator has the wrong type.
 */
func (a *expr) asBool() (func(*Thread) bool) {
	return a.eval.(func(*Thread)(bool))
}
func (a *expr) asUint() (func(*Thread) uint64) {
	return a.eval.(func(*Thread)(uint64))
}
func (a *expr) asInt() (func(*Thread) int64) {
	return a.eval.(func(*Thread)(int64))
}
func (a *expr) asIdealInt() (func() *bignum.Integer) {
	return a.eval.(func()(*bignum.Integer))
}
func (a *expr) asFloat() (func(*Thread) float64) {
	return a.eval.(func(*Thread)(float64))
}
func (a *expr) asIdealFloat() (func() *bignum.Rational) {
	return a.eval.(func()(*bignum.Rational))
}
func (a *expr) asString() (func(*Thread) string) {
	return a.eval.(func(*Thread)(string))
}
func (a *expr) asArray() (func(*Thread) ArrayValue) {
	return a.eval.(func(*Thread)(ArrayValue))
}
func (a *expr) asStruct() (func(*Thread) StructValue) {
	return a.eval.(func(*Thread)(StructValue))
}
func (a *expr) asPtr() (func(*Thread) Value) {
	return a.eval.(func(*Thread)(Value))
}
func (a *expr) asFunc() (func(*Thread) Func) {
	return a.eval.(func(*Thread)(Func))
}
func (a *expr) asSlice() (func(*Thread) Slice) {
	return a.eval.(func(*Thread)(Slice))
}
func (a *expr) asMap() (func(*Thread) Map) {
	return a.eval.(func(*Thread)(Map))
}
func (a *expr) asMulti() (func(*Thread) []Value) {
	return a.eval.(func(*Thread)[]Value)
}

func (a *expr) asInterface() (func(*Thread) interface{}) {
	switch sf := a.eval.(type) {
	case func(*Thread)bool:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)uint64:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)int64:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)*bignum.Integer:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)float64:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)*bignum.Rational:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)string:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)ArrayValue:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)StructValue:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)Value:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)Func:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)Slice:
		return func(t *Thread) interface{} { return sf(t) }
	case func(*Thread)Map:
		return func(t *Thread) interface{} { return sf(t) }
	default:
		log.Crashf("unexpected expression node type %T at %v", a.eval, a.pos);
	}
	panic();
}

/*
 * Operator generators.
 */

func (a *expr) genConstant(v Value) {
	switch _ := a.t.lit().(type) {
	case *boolType:
		val := v.(BoolValue).Get();
		a.eval = func(t *Thread) bool { return val }
	case *uintType:
		val := v.(UintValue).Get();
		a.eval = func(t *Thread) uint64 { return val }
	case *intType:
		val := v.(IntValue).Get();
		a.eval = func(t *Thread) int64 { return val }
	case *idealIntType:
		val := v.(IdealIntValue).Get();
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		val := v.(FloatValue).Get();
		a.eval = func(t *Thread) float64 { return val }
	case *idealFloatType:
		val := v.(IdealFloatValue).Get();
		a.eval = func() *bignum.Rational { return val }
	case *stringType:
		val := v.(StringValue).Get();
		a.eval = func(t *Thread) string { return val }
	case *ArrayType:
		val := v.(ArrayValue).Get();
		a.eval = func(t *Thread) ArrayValue { return val }
	case *StructType:
		val := v.(StructValue).Get();
		a.eval = func(t *Thread) StructValue { return val }
	case *PtrType:
		val := v.(PtrValue).Get();
		a.eval = func(t *Thread) Value { return val }
	case *FuncType:
		val := v.(FuncValue).Get();
		a.eval = func(t *Thread) Func { return val }
	case *SliceType:
		val := v.(SliceValue).Get();
		a.eval = func(t *Thread) Slice { return val }
	case *MapType:
		val := v.(MapValue).Get();
		a.eval = func(t *Thread) Map { return val }
	default:
		log.Crashf("unexpected constant type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genIdentOp(level, index int) {
	a.evalAddr = func(t *Thread) Value { return t.f.Get(level, index) };
	switch _ := a.t.lit().(type) {
	case *boolType:
		a.eval = func(t *Thread) bool { return t.f.Get(level, index).(BoolValue).Get() }
	case *uintType:
		a.eval = func(t *Thread) uint64 { return t.f.Get(level, index).(UintValue).Get() }
	case *intType:
		a.eval = func(t *Thread) int64 { return t.f.Get(level, index).(IntValue).Get() }
	case *floatType:
		a.eval = func(t *Thread) float64 { return t.f.Get(level, index).(FloatValue).Get() }
	case *stringType:
		a.eval = func(t *Thread) string { return t.f.Get(level, index).(StringValue).Get() }
	case *ArrayType:
		a.eval = func(t *Thread) ArrayValue { return t.f.Get(level, index).(ArrayValue).Get() }
	case *StructType:
		a.eval = func(t *Thread) StructValue { return t.f.Get(level, index).(StructValue).Get() }
	case *PtrType:
		a.eval = func(t *Thread) Value { return t.f.Get(level, index).(PtrValue).Get() }
	case *FuncType:
		a.eval = func(t *Thread) Func { return t.f.Get(level, index).(FuncValue).Get() }
	case *SliceType:
		a.eval = func(t *Thread) Slice { return t.f.Get(level, index).(SliceValue).Get() }
	case *MapType:
		a.eval = func(t *Thread) Map { return t.f.Get(level, index).(MapValue).Get() }
	default:
		log.Crashf("unexpected identifier type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genFuncCall(call func(t *Thread) []Value) {
	a.exec = func(t *Thread) { call(t)};
	switch _ := a.t.lit().(type) {
	case *boolType:
		a.eval = func(t *Thread) bool { return call(t)[0].(BoolValue).Get() }
	case *uintType:
		a.eval = func(t *Thread) uint64 { return call(t)[0].(UintValue).Get() }
	case *intType:
		a.eval = func(t *Thread) int64 { return call(t)[0].(IntValue).Get() }
	case *floatType:
		a.eval = func(t *Thread) float64 { return call(t)[0].(FloatValue).Get() }
	case *stringType:
		a.eval = func(t *Thread) string { return call(t)[0].(StringValue).Get() }
	case *ArrayType:
		a.eval = func(t *Thread) ArrayValue { return call(t)[0].(ArrayValue).Get() }
	case *StructType:
		a.eval = func(t *Thread) StructValue { return call(t)[0].(StructValue).Get() }
	case *PtrType:
		a.eval = func(t *Thread) Value { return call(t)[0].(PtrValue).Get() }
	case *FuncType:
		a.eval = func(t *Thread) Func { return call(t)[0].(FuncValue).Get() }
	case *SliceType:
		a.eval = func(t *Thread) Slice { return call(t)[0].(SliceValue).Get() }
	case *MapType:
		a.eval = func(t *Thread) Map { return call(t)[0].(MapValue).Get() }
	case *MultiType:
		a.eval = func(t *Thread) []Value { return call(t) }
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genValue(vf func(*Thread) Value) {
	a.evalAddr = vf;
	switch _ := a.t.lit().(type) {
	case *boolType:
		a.eval = func(t *Thread) bool { return vf(t).(BoolValue).Get() }
	case *uintType:
		a.eval = func(t *Thread) uint64 { return vf(t).(UintValue).Get() }
	case *intType:
		a.eval = func(t *Thread) int64 { return vf(t).(IntValue).Get() }
	case *floatType:
		a.eval = func(t *Thread) float64 { return vf(t).(FloatValue).Get() }
	case *stringType:
		a.eval = func(t *Thread) string { return vf(t).(StringValue).Get() }
	case *ArrayType:
		a.eval = func(t *Thread) ArrayValue { return vf(t).(ArrayValue).Get() }
	case *StructType:
		a.eval = func(t *Thread) StructValue { return vf(t).(StructValue).Get() }
	case *PtrType:
		a.eval = func(t *Thread) Value { return vf(t).(PtrValue).Get() }
	case *FuncType:
		a.eval = func(t *Thread) Func { return vf(t).(FuncValue).Get() }
	case *SliceType:
		a.eval = func(t *Thread) Slice { return vf(t).(SliceValue).Get() }
	case *MapType:
		a.eval = func(t *Thread) Map { return vf(t).(MapValue).Get() }
	default:
		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genUnaryOpNeg(v *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		vf := v.asUint();
		a.eval = func(t *Thread) uint64 { v := vf(t); return -v }
	case *intType:
		vf := v.asInt();
		a.eval = func(t *Thread) int64 { v := vf(t); return -v }
	case *idealIntType:
		v := v.asIdealInt()();
		val := v.Neg();
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		vf := v.asFloat();
		a.eval = func(t *Thread) float64 { v := vf(t); return -v }
	case *idealFloatType:
		v := v.asIdealFloat()();
		val := v.Neg();
		a.eval = func() *bignum.Rational { return val }
	default:
		log.Crashf("unexpected type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genUnaryOpNot(v *expr) {
	switch _ := a.t.lit().(type) {
	case *boolType:
		vf := v.asBool();
		a.eval = func(t *Thread) bool { v := vf(t); return !v }
	default:
		log.Crashf("unexpected type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genUnaryOpXor(v *expr) {
	switch _ := a.t.lit().(type) {
	case *uintType:
		vf := v.asUint();
		a.eval = func(t *Thread) uint64 { v := vf(t); return ^v }
	case *intType:
		vf := v.asInt();
		a.eval = func(t *Thread) int64 { v := vf(t); return ^v }
	case *idealIntType:
		v := v.asIdealInt()();
		val := v.Neg().Sub(bignum.Int(1));
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", a.t, a.pos);
	}
}

func (a *expr) genBinOpAdd(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) uint64 { l, r := lf(t), rf(t); return l + r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) int64 { l, r := lf(t), rf(t); return l + r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Add(r);
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(t *Thread) float64 { l, r := lf(t), rf(t); return l + r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Add(r);
		a.eval = func() *bignum.Rational { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(t *Thread) string { l, r := lf(t), rf(t); return l + r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpSub(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) uint64 { l, r := lf(t), rf(t); return l - r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) int64 { l, r := lf(t), rf(t); return l - r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Sub(r);
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(t *Thread) float64 { l, r := lf(t), rf(t); return l - r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Sub(r);
		a.eval = func() *bignum.Rational { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpMul(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) uint64 { l, r := lf(t), rf(t); return l * r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) int64 { l, r := lf(t), rf(t); return l * r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Mul(r);
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(t *Thread) float64 { l, r := lf(t), rf(t); return l * r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Mul(r);
		a.eval = func() *bignum.Rational { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpQuo(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) uint64 { l, r := lf(t), rf(t); if r == 0 { t.Abort(DivByZeroError{}) } return l / r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) int64 { l, r := lf(t), rf(t); if r == 0 { t.Abort(DivByZeroError{}) } return l / r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Quo(r);
		a.eval = func() *bignum.Integer { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(t *Thread) float64 { l, r := lf(t), rf(t); if r == 0 { t.Abort(DivByZeroError{}) } return l / r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Quo(r);
		a.eval = func() *bignum.Rational { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpRem(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) uint64 { l, r := lf(t), rf(t); if r == 0 { t.Abort(DivByZeroError{}) } return l % r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) int64 { l, r := lf(t), rf(t); if r == 0 { t.Abort(DivByZeroError{}) } return l % r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Rem(r);
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpAnd(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) uint64 { l, r := lf(t), rf(t); return l & r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) int64 { l, r := lf(t), rf(t); return l & r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.And(r);
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpOr(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) uint64 { l, r := lf(t), rf(t); return l | r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) int64 { l, r := lf(t), rf(t); return l | r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Or(r);
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpXor(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) uint64 { l, r := lf(t), rf(t); return l ^ r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) int64 { l, r := lf(t), rf(t); return l ^ r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Xor(r);
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpAndNot(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) uint64 { l, r := lf(t), rf(t); return l &^ r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) int64 { l, r := lf(t), rf(t); return l &^ r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.AndNot(r);
		a.eval = func() *bignum.Integer { return val }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpShl(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) uint64 { l, r := lf(t), rf(t); return l << r }
	case *intType:
		lf := l.asInt();
		rf := r.asUint();
		a.eval = func(t *Thread) int64 { l, r := lf(t), rf(t); return l << r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpShr(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) uint64 { l, r := lf(t), rf(t); return l >> r }
	case *intType:
		lf := l.asInt();
		rf := r.asUint();
		a.eval = func(t *Thread) int64 { l, r := lf(t), rf(t); return l >> r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpLss(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l < r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l < r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) < 0;
		a.eval = func(t *Thread) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l < r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) < 0;
		a.eval = func(t *Thread) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l < r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpGtr(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l > r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l > r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) > 0;
		a.eval = func(t *Thread) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l > r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) > 0;
		a.eval = func(t *Thread) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l > r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpLeq(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l <= r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l <= r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) <= 0;
		a.eval = func(t *Thread) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l <= r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) <= 0;
		a.eval = func(t *Thread) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l <= r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpGeq(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l >= r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l >= r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) >= 0;
		a.eval = func(t *Thread) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l >= r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) >= 0;
		a.eval = func(t *Thread) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l >= r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpEql(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *boolType:
		lf := l.asBool();
		rf := r.asBool();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l == r }
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l == r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l == r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) == 0;
		a.eval = func(t *Thread) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l == r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) == 0;
		a.eval = func(t *Thread) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l == r }
	case *PtrType:
		lf := l.asPtr();
		rf := r.asPtr();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l == r }
	case *FuncType:
		lf := l.asFunc();
		rf := r.asFunc();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l == r }
	case *MapType:
		lf := l.asMap();
		rf := r.asMap();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l == r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func (a *expr) genBinOpNeq(l, r *expr) {
	switch _ := l.t.lit().(type) {
	case *boolType:
		lf := l.asBool();
		rf := r.asBool();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l != r }
	case *uintType:
		lf := l.asUint();
		rf := r.asUint();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l != r }
	case *intType:
		lf := l.asInt();
		rf := r.asInt();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l != r }
	case *idealIntType:
		l := l.asIdealInt()();
		r := r.asIdealInt()();
		val := l.Cmp(r) != 0;
		a.eval = func(t *Thread) bool { return val }
	case *floatType:
		lf := l.asFloat();
		rf := r.asFloat();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l != r }
	case *idealFloatType:
		l := l.asIdealFloat()();
		r := r.asIdealFloat()();
		val := l.Cmp(r) != 0;
		a.eval = func(t *Thread) bool { return val }
	case *stringType:
		lf := l.asString();
		rf := r.asString();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l != r }
	case *PtrType:
		lf := l.asPtr();
		rf := r.asPtr();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l != r }
	case *FuncType:
		lf := l.asFunc();
		rf := r.asFunc();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l != r }
	case *MapType:
		lf := l.asMap();
		rf := r.asMap();
		a.eval = func(t *Thread) bool { l, r := lf(t), rf(t); return l != r }
	default:
		log.Crashf("unexpected type %v at %v", l.t, a.pos);
	}
}

func genAssign(lt Type, r *expr) (func(lv Value, t *Thread)) {
	switch _ := lt.lit().(type) {
	case *boolType:
		rf := r.asBool();
		return func(lv Value, t *Thread) { lv.(BoolValue).Set(rf(t)) }
	case *uintType:
		rf := r.asUint();
		return func(lv Value, t *Thread) { lv.(UintValue).Set(rf(t)) }
	case *intType:
		rf := r.asInt();
		return func(lv Value, t *Thread) { lv.(IntValue).Set(rf(t)) }
	case *floatType:
		rf := r.asFloat();
		return func(lv Value, t *Thread) { lv.(FloatValue).Set(rf(t)) }
	case *stringType:
		rf := r.asString();
		return func(lv Value, t *Thread) { lv.(StringValue).Set(rf(t)) }
	case *ArrayType:
		rf := r.asArray();
		return func(lv Value, t *Thread) { lv.Assign(rf(t)) }
	case *StructType:
		rf := r.asStruct();
		return func(lv Value, t *Thread) { lv.Assign(rf(t)) }
	case *PtrType:
		rf := r.asPtr();
		return func(lv Value, t *Thread) { lv.(PtrValue).Set(rf(t)) }
	case *FuncType:
		rf := r.asFunc();
		return func(lv Value, t *Thread) { lv.(FuncValue).Set(rf(t)) }
	case *SliceType:
		rf := r.asSlice();
		return func(lv Value, t *Thread) { lv.(SliceValue).Set(rf(t)) }
	case *MapType:
		rf := r.asMap();
		return func(lv Value, t *Thread) { lv.(MapValue).Set(rf(t)) }
	default:
		log.Crashf("unexpected left operand type %v at %v", lt, r.pos);
	}
	panic();
}
