// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Format file for printing AST nodes (package "ast").

// ----------------------------------------------------------------------------
// Debugging

token.Token =
	^:string;

array =
	*;

pointer =
	*;

string =
	"%s";

char =
	"%c";

bytes =
	{*};

nil =
	;  // TODO we see a lot of nil's - why?

not_empty =
	*:nil;


// ----------------------------------------------------------------------------
// TODO these are implicit - only here for debugging

ast.Expr =
	*;

ast.Stmt =
	*;

ast.Decl =
	*;


// ----------------------------------------------------------------------------
// Comments

ast.Comment =
	Text:string "\n";

ast.Comments =
	{*};


// ----------------------------------------------------------------------------
// Expressions & Types

ast.Field =
	[Names:not_empty {Names / ", "} " "] Type;

ast.BadExpr =
	"BAD EXPR";

ast.Ident =
	Value;

ast.Ellipsis =
	"...";

ast.IntLit =
	Value:string;

ast.FloatLit =
	Value:string;

ast.CharLit =
	Value:string;

ast.StringLit =
	Value:string;

ast.StringList =
	{Strings / "\n"};

ast.FuncLit =
	"func ";

ast.CompositeLit =
	Type "{" {Elts / ", "} "}";

ast.ParenExpr =
	"(" X ")";

ast.SelectorExpr =
	X "." Sel;

ast.IndexExpr =
	X "[" Index "]";

ast.SliceExpr =
	X "[" Begin ":" End "]";

ast.TypeAssertExpr =
	X ".(" Type ")";

ast.CallExpr =
	Fun "(" {Args / ", "} ")";

ast.StarExpr =
	"*" X;

ast.UnaryExpr =
	Op X;

ast.BinaryExpr =
	X " " Op " " Y;

ast.KeyValueExpr =
	Key ": " Value;

ast.ArrayType =
	"[" Len "]" Elt;

ast.SliceType =
	"[]" Elt;

ast.StructType =
	"struct {"
	[Fields:not_empty
	>> "\t" "\n"
		{Fields / ";\n"}
	<< "\n"
	]
	"}";

signature =
	"(" {Params / ", "} ")" [Results:not_empty " (" {Results / ", "} ")"];

funcSignature =
	*:signature;

ast.FuncType =
	"func" ^:signature;

ast.InterfaceType =
	"interface {"
	[Methods:not_empty
	>> "\t" "\n"
		{Methods / ";\n"}  // TODO should not start with "func"
	<< "\n"
	]
	"}";

ast.MapType =
	"map[" Key "]" Value;

ast.ChanType =
	"chan";


// ----------------------------------------------------------------------------
// Statements

ast.BadStmt =
	"BAD STMT";

ast.DeclStmt =
	Decl;

ast.EmptyStmt =
	;

ast.LabeledStmt =
	Label ":\t" Stmt;

ast.ExprStmt =
	X;

ast.IncDecStmt =
	X Tok;

ast.AssignStmt =
	{Lhs / ", "} " " Tok " " {Rhs / ", "};

ast.GoStmt =
	"go " Call;

ast.ReturnStmt =
	"return" {" " Results / ","};

ast.BranchStmt =
	Tok [" " Label];

blockStmt =  // like ast.BlockStmt but w/o indentation
	"{"
	[List:not_empty
	"\n"
		{List / ";\n"}
	"\n"
	]
	"}";

blockStmtPtr =
	*:blockStmt;

ast.BlockStmt =
	"{"
	[List:not_empty
	>> "\t" "\n"
		{List / ";\n"}
	<< "\n"
	]
	"}";

ast.IfStmt =
	"if " [Init "; "] [Cond " "] Body [" else " Else];

ast.CaseClause =
	( Values:not_empty "case " {Values / ", "}
	| "default"
	)
	":"
	[Body:not_empty
	>> "\t" "\n"
		{Body / ";\n"}
	<<
	];

ast.SwitchStmt =
	"switch " [Init "; "] [Tag " "]
	Body:blockStmtPtr;

ast.TypeCaseClause =
	(	Type:not_empty "case " Type
	|	"default"
	)
	":"
	[Body:not_empty
	>> "\t" "\n"
		{Body / ";\n"}
	<<
	];

ast.TypeSwitchStmt =
	"switch " Assign " "
	Body:blockStmtPtr;

ast.CommClause =
	"CommClause";

ast.SelectStmt =
	"select "
	Body:blockStmtPtr;

ast.ForStmt =
	"for "
	[	Init:not_empty
		[Init] "; " [Cond] "; " [Post " "]
	|	Post:not_empty
		[Init] "; " [Cond] "; " [Post " "]
	|	Cond " "
	]
	Body;

ast.RangeStmt =
	"for " Key [", " Value] " " Tok " range " X
	" "
	Body;


// ----------------------------------------------------------------------------
// Declarations

ast.Spec =
	*;

ast.ImportSpec =
	Doc
	[Name] "\t" {Path};

ast.ValueSpec =
	{Names / ", "} [" " Type] [Values:not_empty " = " {Values / ", "}];

ast.TypeSpec =
	Name " "  // TODO using "\t" instead of " " screws up struct field alignment
	Type;

ast.BadDecl =
	"BAD DECL";

ast.GenDecl =
	Doc
	Tok " ("
	>> "\t" "\n"
		{Specs / ";\n"}
	<<
	"\n"
	")";

ast.FuncDecl =
	"func " ["(" Recv ") "] Name Type:funcSignature
	[" " Body]
	"\n";


// ----------------------------------------------------------------------------
// Program

ast.Program =
	Doc
	"package " Name "\n\n"
	{Decls / "\n\n"};
