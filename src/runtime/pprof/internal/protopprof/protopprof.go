// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package protopprof

import (
	"fmt"
	"os"
	"runtime"
	"strings"
	"time"

	"runtime/pprof/internal/profile"
)

// Copied from encoding/binary package, which can't be imported due to
// dependency cycles

// LittleEndian is the little-endian implementation of ByteOrder.
var lEndian littleEndian

// BigEndian is the big-endian implementation of ByteOrder.
var bEndian bigEndian

type littleEndian struct{}
type bigEndian struct{}

func (bigEndian) uint32(b []byte) uint32 {
	_ = b[3] // bounds check hint to compiler; see golang.org/issue/14808
	return uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24
}

func (bigEndian) uint64(b []byte) uint64 {
	_ = b[7] // bounds check hint to compiler; see golang.org/issue/14808
	return uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |
		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56
}

func (littleEndian) uint32(b []byte) uint32 {
	_ = b[3] // bounds check hint to compiler; see golang.org/issue/14808
	return uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24
}

func (littleEndian) uint64(b []byte) uint64 {
	_ = b[7] // bounds check hint to compiler; see golang.org/issue/14808
	return uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 |
		uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56
}

func big32(b []byte) (uint64, []byte) {
	if len(b) < 4 {
		return 0, nil
	}
	return uint64(bEndian.uint32(b)), b[4:]
}

func little32(b []byte) (uint64, []byte) {
	if len(b) < 4 {
		return 0, nil
	}
	return uint64(lEndian.uint32(b)), b[4:]
}

func big64(b []byte) (uint64, []byte) {
	if len(b) < 8 {
		return 0, nil
	}
	return bEndian.uint64(b), b[8:]
}

func little64(b []byte) (uint64, []byte) {
	if len(b) < 8 {
		return 0, nil
	}
	return lEndian.uint64(b), b[8:]
}

// End of copy from encoding/binary package

type parser func([]byte) (uint64, []byte)

var parsers = []parser{
	big32,
	big64,
	little32,
	little64,
}

// parse returns a parsing function to parse native integers from a buffer.
func findParser(b []byte) parser {
	for _, p := range parsers {
		// If the second word decodes as 3, we have the right parser.
		_, rest := p(b) // first word
		n, _ := p(rest) // second word
		if n == 3 {
			return p
		}
	}
	return nil
}

// decodeHeader parses binary CPU profiling stack trace data
// generated by runtime.CPUProfile() and returns the sample period,
// the rest of the profile and a parse function for parsing the profile. The
// function detects whether the legacy profile format is in little or big
// endian and whether it was generated by a 32-bit or 64-bit machine.
func decodeHeader(b []byte) (period uint64, parse parser, rest []byte, err error) {
	const minRawProfile = 12 // Need a minimum of 3 words, at least 32-bit each.
	if len(b) < minRawProfile {
		return 0, nil, nil, fmt.Errorf("truncated raw profile: len %d", len(b))
	}
	if parse = findParser(b); parse == nil {
		return 0, nil, nil, fmt.Errorf("cannot parse raw profile: header %v", b[:minRawProfile])
	}
	// skip 5-word header; 4th word is period
	_, rest = parse(b)
	_, rest = parse(rest)
	_, rest = parse(rest)
	period, rest = parse(rest)
	_, rest = parse(rest)
	if rest == nil {
		return 0, nil, nil, fmt.Errorf("profile too short")
	}
	return period, parse, rest, nil
}

// translateCPUProfile parses binary CPU profiling stack trace data
// generated by runtime.CPUProfile() into a profile struct.
func TranslateCPUProfile(b []byte, startTime time.Time) (*profile.Profile, error) {
	// Get the sample period from the header.
	var n4 uint64
	var getInt parser
	var err error
	n4, getInt, b, err = decodeHeader(b)
	if err != nil {
		return nil, err
	}

	// profile initialization taken from pprof tool
	p := &profile.Profile{
		Period:     int64(n4) * 1000,
		PeriodType: &profile.ValueType{Type: "cpu", Unit: "nanoseconds"},
		SampleType: []*profile.ValueType{
			{Type: "samples", Unit: "count"},
			{Type: "cpu", Unit: "nanoseconds"},
		},
		TimeNanos:     int64(startTime.UnixNano()),
		DurationNanos: time.Since(startTime).Nanoseconds(),
	}
	// Parse CPU samples from the profile.
	locs := make(map[uint64]*profile.Location)
	for len(b) > 0 {
		var count, nstk uint64
		count, b = getInt(b)
		nstk, b = getInt(b)
		if b == nil {
			return nil, fmt.Errorf("unrecognized profile format")
		}
		var sloc []*profile.Location
		addrs := make([]uint64, nstk)

		for i := 0; i < int(nstk); i++ {
			if b == nil {
				return nil, fmt.Errorf("unrecognized profile format")
			}
			addrs[i], b = getInt(b)
		}
		// End of data marker, can return
		if count == 0 && nstk == 1 && addrs[0] == 0 {
			if runtime.GOOS == "linux" {
				if err := addMappings(p); err != nil {
					return nil, err
				}
			}
			return p, nil
		}
		for i, addr := range addrs {
			// Addresses from stack traces point to the next instruction after
			// each call.  Adjust by -1 to land somewhere on the actual call
			// (except for the leaf, which is not a call).
			if i > 0 {
				addr--
			}
			loc := locs[addr]
			if loc == nil {
				loc = &profile.Location{
					ID:      uint64(len(p.Location) + 1),
					Address: addr,
				}
				locs[addr] = loc
				p.Location = append(p.Location, loc)
			}
			sloc = append(sloc, loc)
		}
		p.Sample = append(p.Sample, &profile.Sample{
			Value:    []int64{int64(count), int64(count) * int64(p.Period)},
			Location: sloc,
		})
	}

	return nil, fmt.Errorf("unrecognized profile format")
}

func addMappings(p *profile.Profile) error {
	// Parse memory map from /proc/self/maps
	f, err := os.Open("/proc/self/maps")
	if err != nil {
		return err
	}
	defer f.Close()
	return p.ParseMemoryMap(f)
}

// Symbolization enables adding names to locations.
func Symbolize(p *profile.Profile) {
	fns := profileFunctionMap{}
	for _, l := range p.Location {
		pc := uintptr(l.Address)
		f := runtime.FuncForPC(pc)
		if f == nil {
			continue
		}
		file, lineno := f.FileLine(pc)
		if l.Mapping != nil {
			if f.Name() != "" {
				l.Mapping.HasFunctions = true
			}
			if file != "" {
				l.Mapping.HasFilenames = true
			}
			if lineno != 0 {
				l.Mapping.HasLineNumbers = true
			}
		}
		l.Line = []profile.Line{
			{
				Function: fns.findOrAddFunction(f.Name(), file, p),
				Line:     int64(lineno),
			},
		}
	}

	// Trim runtime functions. Always hide runtime.goexit. Other runtime
	// functions are only hidden for heapz when they appear at the beginning.
	isHeapz := p.PeriodType != nil && p.PeriodType.Type == "space"
	for _, s := range p.Sample {
		show := !isHeapz
		var i int
		for _, l := range s.Location {
			if (len(l.Line) > 0) && (l.Line[0].Function != nil) {
				name := l.Line[0].Function.Name
				if (name == "runtime.goexit") || (!show && strings.HasPrefix(name, "runtime.")) {
					continue
				}
			}
			show = true
			s.Location[i] = l
			i++
		}
		s.Location = s.Location[:i]
	}
}

type profileFunctionMap map[profile.Function]*profile.Function

func (fns profileFunctionMap) findOrAddFunction(name, filename string, p *profile.Profile) *profile.Function {
	f := profile.Function{
		Name:       name,
		SystemName: name,
		Filename:   filename,
	}
	if fp := fns[f]; fp != nil {
		return fp
	}
	fp := new(profile.Function)
	fns[f] = fp

	*fp = f
	fp.ID = uint64(len(p.Function) + 1)
	p.Function = append(p.Function, fp)
	return fp
}

func CleanupDuplicateLocations(p *profile.Profile) {
	// The profile handler may duplicate the leaf frame, because it gets
	// its address both from stack unwinding and from the signal
	// context. Detect this and delete the duplicate, which has been
	// adjusted by -1. The leaf address should not be adjusted as it is
	// not a call.
	for _, s := range p.Sample {
		if len(s.Location) > 1 && s.Location[0].Address == s.Location[1].Address+1 {
			s.Location = append(s.Location[:1], s.Location[2:]...)
		}
	}
}
