// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// This program generates example_test.go.

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"math/bits"
	"sort"
)

var (
	header = []byte(`// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by go run make_examples.go. DO NOT EDIT.

package bits_test

import (
	"fmt"
	"math/bits"
)

`)

	exampleRegF = `
func Example%s() {
	fmt.Printf("%s\n", %d, bits.%s(%d))
	// Output:
	// %s
}
`
	exampleRevF = `
func Example%s() {
	fmt.Printf("%s\n", %d)
	fmt.Printf("%s\n", bits.%s(%d))
	// Output:
	// %s
	// %s
}
`
)

func main() {
	buf := bytes.NewBuffer(header)

	genReg(buf)
	genRev(buf)

	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile("example_test.go", out, 0666)
	if err != nil {
		log.Fatal(err)
	}
}

func genReg(w io.Writer) {
	examples := []struct {
		name string
		in   int
		out  map[uint]interface{}
	}{
		{
			name: "LeadingZeros",
			in:   1,
			out: map[uint]interface{}{
				8:  bits.LeadingZeros8(1),
				16: bits.LeadingZeros16(1),
				32: bits.LeadingZeros32(1),
				64: bits.LeadingZeros64(1),
			},
		}, {
			name: "TrailingZeros",
			in:   14,
			out: map[uint]interface{}{
				8:  bits.TrailingZeros8(14),
				16: bits.TrailingZeros16(14),
				32: bits.TrailingZeros32(14),
				64: bits.TrailingZeros64(14),
			},
		}, {
			name: "OnesCount",
			in:   14,
			out: map[uint]interface{}{
				8:  bits.OnesCount8(14),
				16: bits.OnesCount16(14),
				32: bits.OnesCount32(14),
				64: bits.OnesCount64(14),
			},
		}, {
			name: "Len",
			in:   8,
			out: map[uint]interface{}{
				8:  bits.Len8(8),
				16: bits.Len16(8),
				32: bits.Len32(8),
				64: bits.Len64(8),
			},
		},
	}

	for _, e := range examples {
		sizes := sortedSizes(e.out)

		for _, size := range sizes {
			fnName := fmt.Sprintf("%s%d", e.name, size)
			outF := fmt.Sprintf("%s(%%0%db) = %%d", fnName, size)
			out := fmt.Sprintf(outF, e.in, e.out[size])

			fmt.Fprintf(w, exampleRegF, fnName, outF, e.in, fnName, e.in, out)
		}
	}
}

func genRev(w io.Writer) {
	examples := []struct {
		name string
		in   int
		out  map[uint]interface{}
	}{
		{
			name: "Reverse",
			in:   19,
			out: map[uint]interface{}{
				8:  bits.Reverse8(19),
				16: bits.Reverse16(19),
				32: bits.Reverse32(19),
				64: bits.Reverse64(19),
			},
		},
	}

	for _, e := range examples {
		sizes := sortedSizes(e.out)

		for _, size := range sizes {
			fnName := fmt.Sprintf("%s%d", e.name, size)
			outF := fmt.Sprintf("%%0%db", size)
			out := fmt.Sprintf(outF, e.in)
			secOut := fmt.Sprintf(outF, e.out[size])

			fmt.Fprintf(w, exampleRevF, fnName, outF, e.in, outF, fnName, e.in, out, secOut)
		}
	}
}

func sortedSizes(out map[uint]interface{}) []uint {
	sizes := make([]uint, 0, len(out))
	for size := range out {
		sizes = append(sizes, size)
	}

	sort.Slice(sizes, func(i, j int) bool {
		return sizes[i] < sizes[j]
	})

	return sizes
}
