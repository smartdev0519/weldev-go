#!/bin/sh
# Copyright 2009 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

# Generate Go code listing error values (ENAMETOOLONG etc)
# and signal values (SIGALRM etc).  They're unrelated except
# that we use the same method for finding them.

errors=$(
	echo '#include <errno.h>' |
	# The gcc command line prints all the #defines
	# it encounters while processing the input
	gcc -x c - -E -dM |
	egrep -h '#define E[A-Z0-9_]+ ' $files |
	sed 's/#define //; s/ .*//'
)

signals=$(
	echo '#include <sys/signal.h>' |
	gcc -x c - -E -dM |
	egrep -h '#define SIG[^_]' |
	egrep -v '#define (SIGEV_|SIGSTKSZ|SIGRT(MIN|MAX))' |
	sed 's/#define //; s/ .*//'
)

# Write godefs input.
(
	echo '#include <errno.h>'
	echo '#include <signal.h>'
	echo 'enum {'
	for i in $errors $signals
	do
		echo '$'"$i = $i,"
	done
	echo '};'
) >_errors.c

echo '// mkerrors.sh' "$@"
echo '// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT'
echo
godefs -gsyscall "$@" _errors.c

# Run C program to print error strings.
(
	echo "
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>

#define nelem(x) (sizeof(x)/sizeof((x)[0]))

enum { A = 'A', Z = 'Z', a = 'a', z = 'z' }; // avoid need for single quotes below

int errors[] = {
"
	for i in $errors
	do
		echo '	'$i,
	done

	echo '
};

int
main(void)
{
	int i, j, e;
	char buf[1024];

	printf("\n\n// Error table\n");
	printf("var errors = [...]string {\n");
	for(i=0; i<nelem(errors); i++) {
		e = errors[i];
		for(j=0; j<i; j++)
			if(errors[j] == e)	// duplicate value
				goto next;
		strcpy(buf, strerror(e));
		// lowercase first letter: Bad -> bad, but STREAM -> STREAM.
		if(A <= buf[0] && buf[0] <= Z && a <= buf[1] && buf[1] <= z)
			buf[0] += a - A;
		printf("\t%d: \"%s\",\n", e, buf);
	next:;
	}
	printf("}\n\n");
}

'
) >_errors.c

gcc -o _errors _errors.c && ./_errors
rm -f _errors.c _errors
