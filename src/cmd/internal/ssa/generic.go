// autogenerated from rulegen/generic.rules: do not edit!
// generated with: go run rulegen/rulegen.go rulegen/generic.rules genericRules generic.go
package ssa

func genericRules(v *Value) bool {
	switch v.Op {
	case OpAdd:
		// match: (Add <t> (Const [c]) (Const [d]))
		// cond: is64BitInt(t) && isSigned(t)
		// result: (Const [{c.(int64)+d.(int64)}])
		{
			t := v.Type
			if v.Args[0].Op != OpConst {
				goto end0
			}
			c := v.Args[0].Aux
			if v.Args[1].Op != OpConst {
				goto end0
			}
			d := v.Args[1].Aux
			if !(is64BitInt(t) && isSigned(t)) {
				goto end0
			}
			v.Op = OpConst
			v.Aux = nil
			v.Args = v.argstorage[:0]
			v.Aux = c.(int64) + d.(int64)
			return true
		}
	end0:
		;
		// match: (Add <t> (Const [c]) (Const [d]))
		// cond: is64BitInt(t) && !isSigned(t)
		// result: (Const [{c.(uint64)+d.(uint64)}])
		{
			t := v.Type
			if v.Args[0].Op != OpConst {
				goto end1
			}
			c := v.Args[0].Aux
			if v.Args[1].Op != OpConst {
				goto end1
			}
			d := v.Args[1].Aux
			if !(is64BitInt(t) && !isSigned(t)) {
				goto end1
			}
			v.Op = OpConst
			v.Aux = nil
			v.Args = v.argstorage[:0]
			v.Aux = c.(uint64) + d.(uint64)
			return true
		}
	end1:
		;
	case OpLoad:
		// match: (Load (FPAddr [offset]) mem)
		// cond:
		// result: (LoadFP [offset] mem)
		{
			if v.Args[0].Op != OpFPAddr {
				goto end2
			}
			offset := v.Args[0].Aux
			mem := v.Args[1]
			v.Op = OpLoadFP
			v.Aux = nil
			v.Args = v.argstorage[:0]
			v.Aux = offset
			v.AddArg(mem)
			return true
		}
	end2:
		;
		// match: (Load (SPAddr [offset]) mem)
		// cond:
		// result: (LoadSP [offset] mem)
		{
			if v.Args[0].Op != OpSPAddr {
				goto end3
			}
			offset := v.Args[0].Aux
			mem := v.Args[1]
			v.Op = OpLoadSP
			v.Aux = nil
			v.Args = v.argstorage[:0]
			v.Aux = offset
			v.AddArg(mem)
			return true
		}
	end3:
		;
	case OpStore:
		// match: (Store (FPAddr [offset]) val mem)
		// cond:
		// result: (StoreFP [offset] val mem)
		{
			if v.Args[0].Op != OpFPAddr {
				goto end4
			}
			offset := v.Args[0].Aux
			val := v.Args[1]
			mem := v.Args[2]
			v.Op = OpStoreFP
			v.Aux = nil
			v.Args = v.argstorage[:0]
			v.Aux = offset
			v.AddArg(val)
			v.AddArg(mem)
			return true
		}
	end4:
		;
		// match: (Store (SPAddr [offset]) val mem)
		// cond:
		// result: (StoreSP [offset] val mem)
		{
			if v.Args[0].Op != OpSPAddr {
				goto end5
			}
			offset := v.Args[0].Aux
			val := v.Args[1]
			mem := v.Args[2]
			v.Op = OpStoreSP
			v.Aux = nil
			v.Args = v.argstorage[:0]
			v.Aux = offset
			v.AddArg(val)
			v.AddArg(mem)
			return true
		}
	end5:
	}
	return false
}
