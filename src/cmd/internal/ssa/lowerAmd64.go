// autogenerated from rulegen/lower_amd64.rules: do not edit!
// generated with: go run rulegen/rulegen.go rulegen/lower_amd64.rules lowerAmd64 lowerAmd64.go
package ssa

func lowerAmd64(v *Value) bool {
	switch v.Op {
	case OpADDCQ:
		// match: (ADDCQ [c] (LEAQ8 [d] x y))
		// cond:
		// result: (LEAQ8 [addOff(c, d)] x y)
		{
			c := v.Aux
			if v.Args[0].Op != OpLEAQ8 {
				goto end3bc1457811adc0cb81ad6b88a7461c60
			}
			d := v.Args[0].Aux
			x := v.Args[0].Args[0]
			y := v.Args[0].Args[1]
			v.Op = OpLEAQ8
			v.Aux = nil
			v.resetArgs()
			v.Aux = addOff(c, d)
			v.AddArg(x)
			v.AddArg(y)
			return true
		}
		goto end3bc1457811adc0cb81ad6b88a7461c60
	end3bc1457811adc0cb81ad6b88a7461c60:
		;
		// match: (ADDCQ [off] x)
		// cond: off.(int64) == 0
		// result: (Copy x)
		{
			off := v.Aux
			x := v.Args[0]
			if !(off.(int64) == 0) {
				goto end6710a6679c47b70577ecea7ad00dae87
			}
			v.Op = OpCopy
			v.Aux = nil
			v.resetArgs()
			v.AddArg(x)
			return true
		}
		goto end6710a6679c47b70577ecea7ad00dae87
	end6710a6679c47b70577ecea7ad00dae87:
		;
	case OpADDQ:
		// match: (ADDQ x (MOVQconst [c]))
		// cond:
		// result: (ADDCQ [c] x)
		{
			x := v.Args[0]
			if v.Args[1].Op != OpMOVQconst {
				goto end39b79e84f20a6d44b5c4136aae220ac2
			}
			c := v.Args[1].Aux
			v.Op = OpADDCQ
			v.Aux = nil
			v.resetArgs()
			v.Aux = c
			v.AddArg(x)
			return true
		}
		goto end39b79e84f20a6d44b5c4136aae220ac2
	end39b79e84f20a6d44b5c4136aae220ac2:
		;
		// match: (ADDQ (MOVQconst [c]) x)
		// cond:
		// result: (ADDCQ [c] x)
		{
			if v.Args[0].Op != OpMOVQconst {
				goto endc05ff5a2a132241b69d00c852001d820
			}
			c := v.Args[0].Aux
			x := v.Args[1]
			v.Op = OpADDCQ
			v.Aux = nil
			v.resetArgs()
			v.Aux = c
			v.AddArg(x)
			return true
		}
		goto endc05ff5a2a132241b69d00c852001d820
	endc05ff5a2a132241b69d00c852001d820:
		;
		// match: (ADDQ x (SHLCQ [shift] y))
		// cond: shift.(int64) == 3
		// result: (LEAQ8 [int64(0)] x y)
		{
			x := v.Args[0]
			if v.Args[1].Op != OpSHLCQ {
				goto end7fa0d837edd248748cef516853fd9475
			}
			shift := v.Args[1].Aux
			y := v.Args[1].Args[0]
			if !(shift.(int64) == 3) {
				goto end7fa0d837edd248748cef516853fd9475
			}
			v.Op = OpLEAQ8
			v.Aux = nil
			v.resetArgs()
			v.Aux = int64(0)
			v.AddArg(x)
			v.AddArg(y)
			return true
		}
		goto end7fa0d837edd248748cef516853fd9475
	end7fa0d837edd248748cef516853fd9475:
		;
	case OpAdd:
		// match: (Add <t> x y)
		// cond: (is64BitInt(t) || isPtr(t))
		// result: (ADDQ x y)
		{
			t := v.Type
			x := v.Args[0]
			y := v.Args[1]
			if !(is64BitInt(t) || isPtr(t)) {
				goto endf031c523d7dd08e4b8e7010a94cd94c9
			}
			v.Op = OpADDQ
			v.Aux = nil
			v.resetArgs()
			v.AddArg(x)
			v.AddArg(y)
			return true
		}
		goto endf031c523d7dd08e4b8e7010a94cd94c9
	endf031c523d7dd08e4b8e7010a94cd94c9:
		;
		// match: (Add <t> x y)
		// cond: is32BitInt(t)
		// result: (ADDL x y)
		{
			t := v.Type
			x := v.Args[0]
			y := v.Args[1]
			if !(is32BitInt(t)) {
				goto end35a02a1587264e40cf1055856ff8445a
			}
			v.Op = OpADDL
			v.Aux = nil
			v.resetArgs()
			v.AddArg(x)
			v.AddArg(y)
			return true
		}
		goto end35a02a1587264e40cf1055856ff8445a
	end35a02a1587264e40cf1055856ff8445a:
		;
	case OpCMPQ:
		// match: (CMPQ x (MOVQconst [c]))
		// cond:
		// result: (CMPCQ x [c])
		{
			x := v.Args[0]
			if v.Args[1].Op != OpMOVQconst {
				goto endf180bae15b3d24c0213520d7f7aa98b4
			}
			c := v.Args[1].Aux
			v.Op = OpCMPCQ
			v.Aux = nil
			v.resetArgs()
			v.AddArg(x)
			v.Aux = c
			return true
		}
		goto endf180bae15b3d24c0213520d7f7aa98b4
	endf180bae15b3d24c0213520d7f7aa98b4:
		;
		// match: (CMPQ (MOVQconst [c]) x)
		// cond:
		// result: (InvertFlags (CMPCQ <TypeFlags> x [c]))
		{
			if v.Args[0].Op != OpMOVQconst {
				goto end8fc58bffa73b3df80b3de72c91844884
			}
			c := v.Args[0].Aux
			x := v.Args[1]
			v.Op = OpInvertFlags
			v.Aux = nil
			v.resetArgs()
			v0 := v.Block.NewValue(OpCMPCQ, TypeInvalid, nil)
			v0.Type = TypeFlags
			v0.AddArg(x)
			v0.Aux = c
			v.AddArg(v0)
			return true
		}
		goto end8fc58bffa73b3df80b3de72c91844884
	end8fc58bffa73b3df80b3de72c91844884:
		;
	case OpConst:
		// match: (Const <t> [val])
		// cond: is64BitInt(t)
		// result: (MOVQconst [val])
		{
			t := v.Type
			val := v.Aux
			if !(is64BitInt(t)) {
				goto end7f5c5b34093fbc6860524cb803ee51bf
			}
			v.Op = OpMOVQconst
			v.Aux = nil
			v.resetArgs()
			v.Aux = val
			return true
		}
		goto end7f5c5b34093fbc6860524cb803ee51bf
	end7f5c5b34093fbc6860524cb803ee51bf:
		;
	case OpGlobal:
		// match: (Global [sym])
		// cond:
		// result: (LEAQglobal [GlobalOffset{sym,0}])
		{
			sym := v.Aux
			v.Op = OpLEAQglobal
			v.Aux = nil
			v.resetArgs()
			v.Aux = GlobalOffset{sym, 0}
			return true
		}
		goto end3a3c76fac0e2e53c0e1c60b9524e6f1c
	end3a3c76fac0e2e53c0e1c60b9524e6f1c:
		;
	case OpIsInBounds:
		// match: (IsInBounds idx len)
		// cond:
		// result: (SETB (CMPQ <TypeFlags> idx len))
		{
			idx := v.Args[0]
			len := v.Args[1]
			v.Op = OpSETB
			v.Aux = nil
			v.resetArgs()
			v0 := v.Block.NewValue(OpCMPQ, TypeInvalid, nil)
			v0.Type = TypeFlags
			v0.AddArg(idx)
			v0.AddArg(len)
			v.AddArg(v0)
			return true
		}
		goto endb51d371171154c0f1613b687757e0576
	endb51d371171154c0f1613b687757e0576:
		;
	case OpIsNonNil:
		// match: (IsNonNil p)
		// cond:
		// result: (SETNE (TESTQ <TypeFlags> p p))
		{
			p := v.Args[0]
			v.Op = OpSETNE
			v.Aux = nil
			v.resetArgs()
			v0 := v.Block.NewValue(OpTESTQ, TypeInvalid, nil)
			v0.Type = TypeFlags
			v0.AddArg(p)
			v0.AddArg(p)
			v.AddArg(v0)
			return true
		}
		goto endff508c3726edfb573abc6128c177e76c
	endff508c3726edfb573abc6128c177e76c:
		;
	case OpLess:
		// match: (Less x y)
		// cond: is64BitInt(v.Args[0].Type) && isSigned(v.Args[0].Type)
		// result: (SETL (CMPQ <TypeFlags> x y))
		{
			x := v.Args[0]
			y := v.Args[1]
			if !(is64BitInt(v.Args[0].Type) && isSigned(v.Args[0].Type)) {
				goto endcecf13a952d4c6c2383561c7d68a3cf9
			}
			v.Op = OpSETL
			v.Aux = nil
			v.resetArgs()
			v0 := v.Block.NewValue(OpCMPQ, TypeInvalid, nil)
			v0.Type = TypeFlags
			v0.AddArg(x)
			v0.AddArg(y)
			v.AddArg(v0)
			return true
		}
		goto endcecf13a952d4c6c2383561c7d68a3cf9
	endcecf13a952d4c6c2383561c7d68a3cf9:
		;
	case OpLoad:
		// match: (Load <t> ptr mem)
		// cond: t.IsBoolean()
		// result: (MOVBload [int64(0)] ptr mem)
		{
			t := v.Type
			ptr := v.Args[0]
			mem := v.Args[1]
			if !(t.IsBoolean()) {
				goto end73f21632e56c3614902d3c29c82dc4ea
			}
			v.Op = OpMOVBload
			v.Aux = nil
			v.resetArgs()
			v.Aux = int64(0)
			v.AddArg(ptr)
			v.AddArg(mem)
			return true
		}
		goto end73f21632e56c3614902d3c29c82dc4ea
	end73f21632e56c3614902d3c29c82dc4ea:
		;
		// match: (Load <t> ptr mem)
		// cond: (is64BitInt(t) || isPtr(t))
		// result: (MOVQload [int64(0)] ptr mem)
		{
			t := v.Type
			ptr := v.Args[0]
			mem := v.Args[1]
			if !(is64BitInt(t) || isPtr(t)) {
				goto end581ce5a20901df1b8143448ba031685b
			}
			v.Op = OpMOVQload
			v.Aux = nil
			v.resetArgs()
			v.Aux = int64(0)
			v.AddArg(ptr)
			v.AddArg(mem)
			return true
		}
		goto end581ce5a20901df1b8143448ba031685b
	end581ce5a20901df1b8143448ba031685b:
		;
	case OpMOVQload:
		// match: (MOVQload [off1] (ADDCQ [off2] ptr) mem)
		// cond:
		// result: (MOVQload [addOff(off1, off2)] ptr mem)
		{
			off1 := v.Aux
			if v.Args[0].Op != OpADDCQ {
				goto end218ceec16b8299d573d3c9ccaa69b086
			}
			off2 := v.Args[0].Aux
			ptr := v.Args[0].Args[0]
			mem := v.Args[1]
			v.Op = OpMOVQload
			v.Aux = nil
			v.resetArgs()
			v.Aux = addOff(off1, off2)
			v.AddArg(ptr)
			v.AddArg(mem)
			return true
		}
		goto end218ceec16b8299d573d3c9ccaa69b086
	end218ceec16b8299d573d3c9ccaa69b086:
		;
		// match: (MOVQload [off1] (LEAQ8 [off2] ptr idx) mem)
		// cond:
		// result: (MOVQloadidx8 [addOff(off1, off2)] ptr idx mem)
		{
			off1 := v.Aux
			if v.Args[0].Op != OpLEAQ8 {
				goto end02f5ad148292c46463e7c20d3b821735
			}
			off2 := v.Args[0].Aux
			ptr := v.Args[0].Args[0]
			idx := v.Args[0].Args[1]
			mem := v.Args[1]
			v.Op = OpMOVQloadidx8
			v.Aux = nil
			v.resetArgs()
			v.Aux = addOff(off1, off2)
			v.AddArg(ptr)
			v.AddArg(idx)
			v.AddArg(mem)
			return true
		}
		goto end02f5ad148292c46463e7c20d3b821735
	end02f5ad148292c46463e7c20d3b821735:
		;
	case OpMOVQloadidx8:
		// match: (MOVQloadidx8 [off1] (ADDCQ [off2] ptr) idx mem)
		// cond:
		// result: (MOVQloadidx8 [addOff(off1, off2)] ptr idx mem)
		{
			off1 := v.Aux
			if v.Args[0].Op != OpADDCQ {
				goto ende47e8d742e2615f39fb6509a5749e414
			}
			off2 := v.Args[0].Aux
			ptr := v.Args[0].Args[0]
			idx := v.Args[1]
			mem := v.Args[2]
			v.Op = OpMOVQloadidx8
			v.Aux = nil
			v.resetArgs()
			v.Aux = addOff(off1, off2)
			v.AddArg(ptr)
			v.AddArg(idx)
			v.AddArg(mem)
			return true
		}
		goto ende47e8d742e2615f39fb6509a5749e414
	ende47e8d742e2615f39fb6509a5749e414:
		;
	case OpMOVQstore:
		// match: (MOVQstore [off1] (ADDCQ [off2] ptr) val mem)
		// cond:
		// result: (MOVQstore [addOff(off1, off2)] ptr val mem)
		{
			off1 := v.Aux
			if v.Args[0].Op != OpADDCQ {
				goto enddfd4c7a20fd3b84eb9dcf84b98c661fc
			}
			off2 := v.Args[0].Aux
			ptr := v.Args[0].Args[0]
			val := v.Args[1]
			mem := v.Args[2]
			v.Op = OpMOVQstore
			v.Aux = nil
			v.resetArgs()
			v.Aux = addOff(off1, off2)
			v.AddArg(ptr)
			v.AddArg(val)
			v.AddArg(mem)
			return true
		}
		goto enddfd4c7a20fd3b84eb9dcf84b98c661fc
	enddfd4c7a20fd3b84eb9dcf84b98c661fc:
		;
		// match: (MOVQstore [off1] (LEAQ8 [off2] ptr idx) val mem)
		// cond:
		// result: (MOVQstoreidx8 [addOff(off1, off2)] ptr idx val mem)
		{
			off1 := v.Aux
			if v.Args[0].Op != OpLEAQ8 {
				goto endce1db8c8d37c8397c500a2068a65c215
			}
			off2 := v.Args[0].Aux
			ptr := v.Args[0].Args[0]
			idx := v.Args[0].Args[1]
			val := v.Args[1]
			mem := v.Args[2]
			v.Op = OpMOVQstoreidx8
			v.Aux = nil
			v.resetArgs()
			v.Aux = addOff(off1, off2)
			v.AddArg(ptr)
			v.AddArg(idx)
			v.AddArg(val)
			v.AddArg(mem)
			return true
		}
		goto endce1db8c8d37c8397c500a2068a65c215
	endce1db8c8d37c8397c500a2068a65c215:
		;
	case OpMOVQstoreidx8:
		// match: (MOVQstoreidx8 [off1] (ADDCQ [off2] ptr) idx val mem)
		// cond:
		// result: (MOVQstoreidx8 [addOff(off1, off2)] ptr idx val mem)
		{
			off1 := v.Aux
			if v.Args[0].Op != OpADDCQ {
				goto endcdb222707a568ad468f7fff2fc42fc39
			}
			off2 := v.Args[0].Aux
			ptr := v.Args[0].Args[0]
			idx := v.Args[1]
			val := v.Args[2]
			mem := v.Args[3]
			v.Op = OpMOVQstoreidx8
			v.Aux = nil
			v.resetArgs()
			v.Aux = addOff(off1, off2)
			v.AddArg(ptr)
			v.AddArg(idx)
			v.AddArg(val)
			v.AddArg(mem)
			return true
		}
		goto endcdb222707a568ad468f7fff2fc42fc39
	endcdb222707a568ad468f7fff2fc42fc39:
		;
	case OpMULCQ:
		// match: (MULCQ [c] x)
		// cond: c.(int64) == 8
		// result: (SHLCQ [int64(3)] x)
		{
			c := v.Aux
			x := v.Args[0]
			if !(c.(int64) == 8) {
				goto end90a1c055d9658aecacce5e101c1848b4
			}
			v.Op = OpSHLCQ
			v.Aux = nil
			v.resetArgs()
			v.Aux = int64(3)
			v.AddArg(x)
			return true
		}
		goto end90a1c055d9658aecacce5e101c1848b4
	end90a1c055d9658aecacce5e101c1848b4:
		;
	case OpMULQ:
		// match: (MULQ x (MOVQconst [c]))
		// cond:
		// result: (MULCQ [c] x)
		{
			x := v.Args[0]
			if v.Args[1].Op != OpMOVQconst {
				goto endce35d001482ea209e62e9394bd07c7cb
			}
			c := v.Args[1].Aux
			v.Op = OpMULCQ
			v.Aux = nil
			v.resetArgs()
			v.Aux = c
			v.AddArg(x)
			return true
		}
		goto endce35d001482ea209e62e9394bd07c7cb
	endce35d001482ea209e62e9394bd07c7cb:
		;
		// match: (MULQ (MOVQconst [c]) x)
		// cond:
		// result: (MULCQ [c] x)
		{
			if v.Args[0].Op != OpMOVQconst {
				goto end804f58b1f6a7cce19d48379999ec03f1
			}
			c := v.Args[0].Aux
			x := v.Args[1]
			v.Op = OpMULCQ
			v.Aux = nil
			v.resetArgs()
			v.Aux = c
			v.AddArg(x)
			return true
		}
		goto end804f58b1f6a7cce19d48379999ec03f1
	end804f58b1f6a7cce19d48379999ec03f1:
		;
	case OpMove:
		// match: (Move [size] dst src mem)
		// cond:
		// result: (REPMOVSB dst src (Const <TypeUInt64> [size.(int64)]) mem)
		{
			size := v.Aux
			dst := v.Args[0]
			src := v.Args[1]
			mem := v.Args[2]
			v.Op = OpREPMOVSB
			v.Aux = nil
			v.resetArgs()
			v.AddArg(dst)
			v.AddArg(src)
			v0 := v.Block.NewValue(OpConst, TypeInvalid, nil)
			v0.Type = TypeUInt64
			v0.Aux = size.(int64)
			v.AddArg(v0)
			v.AddArg(mem)
			return true
		}
		goto end48909259b265a6bb2a076bc2c2dc7d1f
	end48909259b265a6bb2a076bc2c2dc7d1f:
		;
	case OpMul:
		// match: (Mul <t> x y)
		// cond: is64BitInt(t)
		// result: (MULQ x y)
		{
			t := v.Type
			x := v.Args[0]
			y := v.Args[1]
			if !(is64BitInt(t)) {
				goto endfab0d598f376ecba45a22587d50f7aff
			}
			v.Op = OpMULQ
			v.Aux = nil
			v.resetArgs()
			v.AddArg(x)
			v.AddArg(y)
			return true
		}
		goto endfab0d598f376ecba45a22587d50f7aff
	endfab0d598f376ecba45a22587d50f7aff:
		;
	case OpOffPtr:
		// match: (OffPtr [off] ptr)
		// cond:
		// result: (ADDCQ [off] ptr)
		{
			off := v.Aux
			ptr := v.Args[0]
			v.Op = OpADDCQ
			v.Aux = nil
			v.resetArgs()
			v.Aux = off
			v.AddArg(ptr)
			return true
		}
		goto endfe8f713b1d237a23311fb721ee46bedb
	endfe8f713b1d237a23311fb721ee46bedb:
		;
	case OpSETL:
		// match: (SETL (InvertFlags x))
		// cond:
		// result: (SETGE x)
		{
			if v.Args[0].Op != OpInvertFlags {
				goto end456c7681d48305698c1ef462d244bdc6
			}
			x := v.Args[0].Args[0]
			v.Op = OpSETGE
			v.Aux = nil
			v.resetArgs()
			v.AddArg(x)
			return true
		}
		goto end456c7681d48305698c1ef462d244bdc6
	end456c7681d48305698c1ef462d244bdc6:
		;
	case OpSUBQ:
		// match: (SUBQ x (MOVQconst [c]))
		// cond:
		// result: (SUBCQ x [c])
		{
			x := v.Args[0]
			if v.Args[1].Op != OpMOVQconst {
				goto endc96cd1cb2dd98427c34fb9543feca4fe
			}
			c := v.Args[1].Aux
			v.Op = OpSUBCQ
			v.Aux = nil
			v.resetArgs()
			v.AddArg(x)
			v.Aux = c
			return true
		}
		goto endc96cd1cb2dd98427c34fb9543feca4fe
	endc96cd1cb2dd98427c34fb9543feca4fe:
		;
		// match: (SUBQ <t> (MOVQconst [c]) x)
		// cond:
		// result: (NEGQ (SUBCQ <t> x [c]))
		{
			t := v.Type
			if v.Args[0].Op != OpMOVQconst {
				goto end900aaaf28cefac6bb62e76b5151611cf
			}
			c := v.Args[0].Aux
			x := v.Args[1]
			v.Op = OpNEGQ
			v.Aux = nil
			v.resetArgs()
			v0 := v.Block.NewValue(OpSUBCQ, TypeInvalid, nil)
			v0.Type = t
			v0.AddArg(x)
			v0.Aux = c
			v.AddArg(v0)
			return true
		}
		goto end900aaaf28cefac6bb62e76b5151611cf
	end900aaaf28cefac6bb62e76b5151611cf:
		;
	case OpStore:
		// match: (Store ptr val mem)
		// cond: (is64BitInt(val.Type) || isPtr(val.Type))
		// result: (MOVQstore [int64(0)] ptr val mem)
		{
			ptr := v.Args[0]
			val := v.Args[1]
			mem := v.Args[2]
			if !(is64BitInt(val.Type) || isPtr(val.Type)) {
				goto end9680b43f504bc06f9fab000823ce471a
			}
			v.Op = OpMOVQstore
			v.Aux = nil
			v.resetArgs()
			v.Aux = int64(0)
			v.AddArg(ptr)
			v.AddArg(val)
			v.AddArg(mem)
			return true
		}
		goto end9680b43f504bc06f9fab000823ce471a
	end9680b43f504bc06f9fab000823ce471a:
		;
	case OpSub:
		// match: (Sub <t> x y)
		// cond: is64BitInt(t)
		// result: (SUBQ x y)
		{
			t := v.Type
			x := v.Args[0]
			y := v.Args[1]
			if !(is64BitInt(t)) {
				goto ende6ef29f885a8ecf3058212bb95917323
			}
			v.Op = OpSUBQ
			v.Aux = nil
			v.resetArgs()
			v.AddArg(x)
			v.AddArg(y)
			return true
		}
		goto ende6ef29f885a8ecf3058212bb95917323
	ende6ef29f885a8ecf3058212bb95917323:
	}
	return false
}
