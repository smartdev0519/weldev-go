// Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gobuild

import (
	"fmt";
	"io";
	"path";
	"template";

	"./gobuild";
)

var makefileTemplate = `
# DO NOT EDIT.  Automatically generated by gobuild.
{Args|args} >Makefile

D={.section Dir}/{@}{.end}

include $(GOROOT)/src/Make.$(GOARCH)
AR=gopack

default: packages

clean:
	rm -rf *.[$(OS)] *.a [$(OS)].out {ObjDir}

test: packages
	gotest

coverage: packages
	gotest
	6cov -g $$(pwd) | grep -v '_test\.go:'

%.$O: %.go
	$(GC) -I{ObjDir} $*.go

%.$O: %.c
	$(CC) $*.c

%.$O: %.s
	$(AS) $*.s

{.repeated section Phases}
O{Phase}=\
{.repeated section ArCmds}
{.repeated section Files}
	{Name|basename}.$O\
{.end}
{.end}

{.end}

phases:{.repeated section Phases} a{Phase}{.end}
{.repeated section Packages}
{ObjDir}$D/{Name}.a: phases
{.end}

{.repeated section Phases}
a{Phase}: $(O{Phase})
{.repeated section ArCmds}
	$(AR) grc {ObjDir}$D/{.section Pkg}{Name}.a{.end}{.repeated section Files} {Name|basename}.$O{.end}
{.end}
	rm -f $(O{Phase})

{.end}

newpkg: clean
	mkdir -p {ObjDir}$D
{.repeated section Packages}
	$(AR) grc {ObjDir}$D/{Name}.a
{.end}

$(O1): newpkg
{.repeated section Phases}
$(O{Phase|+1}): a{Phase}
{.end}

nuke: clean
	rm -f{.repeated section Packages} $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/{Name}.a{.end}

packages:{.repeated section Packages} {ObjDir}$D/{Name}.a{.end}

install: packages
	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
{.repeated section Packages}
	cp {ObjDir}$D/{Name}.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/{Name}.a
{.end}
`

func argsFmt(w io.Writer, x interface{}, format string) {
	args := x.([]string);
	fmt.Fprint(w, "#");
	for i, a := range args {
		fmt.Fprint(w, " ", ShellString(a));
	}
}

func basenameFmt(w io.Writer, x interface{}, format string) {
	t := fmt.Sprint(x);
	t = t[0:len(t)-len(path.Ext(t))];
	fmt.Fprint(w, MakeString(t));
}

func plus1Fmt(w io.Writer, x interface{}, format string) {
	fmt.Fprint(w, x.(int) + 1);
}

func makeFmt(w io.Writer, x interface{}, format string) {
	fmt.Fprint(w, MakeString(fmt.Sprint(x)));
}

var makefileMap = template.FormatterMap {
	"": makeFmt,
	"+1": plus1Fmt,
	"args": argsFmt,
	"basename": basenameFmt,
}
