// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// Generate builtin.go from builtin/runtime.go and builtin/unsafe.go.
// Run this after changing builtin/runtime.go and builtin/unsafe.go
// or after changing the export metadata format in the compiler.
// Either way, you need to have a working compiler binary first.
package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
)

func main() {
	var b bytes.Buffer
	fmt.Fprintln(&b, "// AUTO-GENERATED by mkbuiltin.go; DO NOT EDIT")
	fmt.Fprintln(&b, "")
	fmt.Fprintln(&b, "package gc")

	mkbuiltin(&b, "runtime")
	mkbuiltin(&b, "unsafe")

	if err := ioutil.WriteFile("builtin.go", b.Bytes(), 0666); err != nil {
		log.Fatal(err)
	}
}

// Compile .go file, import data from .o file, and write Go string version.
func mkbuiltin(w io.Writer, name string) {
	args := []string{"tool", "compile", "-A"}
	if name == "runtime" {
		args = append(args, "-u")
	}
	args = append(args, "builtin/"+name+".go")

	if err := exec.Command("go", args...).Run(); err != nil {
		log.Fatal(err)
	}
	obj := name + ".o"
	defer os.Remove(obj)

	b, err := ioutil.ReadFile(obj)
	if err != nil {
		log.Fatal(err)
	}

	// Look for $$ that introduces imports.
	i := bytes.Index(b, []byte("\n$$\n"))
	if i < 0 {
		log.Fatal("did not find beginning of imports")
	}
	i += 4

	// Look for $$ that closes imports.
	j := bytes.Index(b[i:], []byte("\n$$\n"))
	if j < 0 {
		log.Fatal("did not find end of imports")
	}
	j += i + 4

	// Process and reformat imports.
	fmt.Fprintf(w, "\nconst %simport = \"\"", name)
	for _, p := range bytes.SplitAfter(b[i:j], []byte("\n")) {
		// Chop leading white space.
		p = bytes.TrimLeft(p, " \t")
		if len(p) == 0 {
			continue
		}

		fmt.Fprintf(w, " +\n\t%q", p)
	}
	fmt.Fprintf(w, "\n")
}
