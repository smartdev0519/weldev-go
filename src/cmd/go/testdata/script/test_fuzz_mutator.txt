# TODO(jayconrod): support shared memory on more platforms.
[!darwin] [!linux] [!windows] skip

# Test basic fuzzing mutator behavior.
#
# fuzz_test.go has two fuzz targets (FuzzA, FuzzB) which both add a seed value.
# Each fuzz function writes the input to a log file. The coordinator and worker
# use separate log files. check_logs.go verifies that the coordinator only
# tests seed values and the worker tests mutated values on the fuzz target.

[short] skip

go test -fuzz=FuzzA -fuzztime=100x -parallel=1 -log=fuzz
go run check_logs.go fuzz fuzz.worker

# Test that the mutator is good enough to find several unique mutations.
! go test -fuzz=FuzzMutator -parallel=1 -fuzztime=100x mutator_test.go
! stdout '^ok'
stdout FAIL
stdout 'mutator found enough unique mutations'

# Test that minimization is working for recoverable errors.
! go test -fuzz=FuzzMinimizerRecoverable -run=FuzzMinimizerRecoverable -fuzztime=1000x minimizer_test.go
! stdout '^ok'
stdout 'got the minimum size!'
stdout 'contains a letter'
stdout FAIL

# Check that the bytes written to testdata are of length 50 (the minimum size)
go run check_testdata.go FuzzMinimizerRecoverable 50

# Test that re-running the minimized value causes a crash.
! go test -run=FuzzMinimizerRecoverable minimizer_test.go

# Test that minimization is working for non-recoverable errors.
! go test -fuzz=FuzzMinimizerNonrecoverable -run=FuzzMinimizerNonrecoverable -fuzztime=1000x minimizer_test.go
! stdout '^ok'
stdout 'got the minimum size!'
stdout 'contains a letter'
stdout FAIL

# Check that the bytes written to testdata are of length 50 (the minimum size)
go run check_testdata.go FuzzMinimizerNonrecoverable 50

# Test that minimization can be cancelled by fuzztime and the latest crash will
# still be logged and written to testdata.
! go test -fuzz=FuzzNonMinimizable -run=FuzzNonMinimizable -parallel=1 -fuzztime=5s minimizer_test.go
! stdout '^ok'
stdout 'testdata[/\\]corpus[/\\]FuzzNonMinimizable[/\\]'
! stdout 'got the minimum size!'  # it shouldn't have had enough time to minimize it
stdout 'at least 20 bytes'
stdout FAIL

# TODO(jayconrod,katiehockman): add a test which verifies that the right bytes
# are written to testdata in the case of an interrupt during minimization.

-- go.mod --
module m

go 1.16
-- fuzz_test.go --
package fuzz_test

import (
	"flag"
	"fmt"
	"os"
	"testing"
)

var (
	logPath = flag.String("log", "", "path to log file")
	logFile *os.File
)

func TestMain(m *testing.M) {
	flag.Parse()
	var err error
	logFile, err = os.OpenFile(*logPath, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)
	if os.IsExist(err) {
		*logPath += ".worker"
		logFile, err = os.OpenFile(*logPath, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)
	}
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	os.Exit(m.Run())
}

func FuzzA(f *testing.F) {
	f.Add([]byte("seed"))
	f.Fuzz(func(t *testing.T, b []byte) {
		fmt.Fprintf(logFile, "FuzzA %q\n", b)
	})
}

func FuzzB(f *testing.F) {
	f.Add([]byte("seed"))
	f.Fuzz(func(t *testing.T, b []byte) {
		fmt.Fprintf(logFile, "FuzzB %q\n", b)
	})
}

-- minimizer_test.go --
package fuzz_test

import (
	"bytes"
	"testing"
	"time"
)

func FuzzMinimizerRecoverable(f *testing.F) {
	f.Fuzz(func(t *testing.T, b []byte) {
		if len(b) < 50 {
			// Make sure that b is large enough that it can be minimized
			return
		}
		// Given the randomness of the mutations, this should allow the
		// minimizer to trim down the value a bit.
		if bytes.ContainsAny(b, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") {
			if len(b) == 50 {
				t.Log("got the minimum size!")
			}
			t.Error("contains a letter")
		}
	})
}

func FuzzMinimizerNonrecoverable(f *testing.F) {
	f.Fuzz(func(t *testing.T, b []byte) {
		if len(b) < 50 {
			// Make sure that b is large enough that it can be minimized
			return
		}
		// Given the randomness of the mutations, this should allow the
		// minimizer to trim down the value quite a bit.
		if bytes.ContainsAny(b, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") {
			if len(b) == 50 {
				t.Log("got the minimum size!")
			}
			panic("contains a letter")
		}
	})
}

func FuzzNonMinimizable(f *testing.F) {
	f.Fuzz(func(t *testing.T, b []byte) {
		if len(b) < 20 {
			// Make sure that b is large enough that minimization will try to run.
			return
		}
		panic("at least 20 bytes")
		if len(b) == 20 {
			t.Log("got the minimum size!")
		}
		time.Sleep(4 * time.Second)
	})
}

-- check_logs.go --
// +build ignore

package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strings"
)

func main() {
	coordPath, workerPath := os.Args[1], os.Args[2]

	coordLog, err := os.Open(coordPath)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	defer coordLog.Close()
	if err := checkCoordLog(coordLog); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	workerLog, err := os.Open(workerPath)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	defer workerLog.Close()
	if err := checkWorkerLog(workerLog); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func checkCoordLog(r io.Reader) error {
	scan := bufio.NewScanner(r)
	var sawASeed, sawBSeed bool
	for scan.Scan() {
		line := scan.Text()
		switch {
		case line == `FuzzA "seed"`:
			if sawASeed {
				return fmt.Errorf("coordinator: tested FuzzA seed multiple times")
			}
			sawASeed = true

		case line == `FuzzB "seed"`:
			if sawBSeed {
				return fmt.Errorf("coordinator: tested FuzzB seed multiple times")
			}
			sawBSeed = true

		default:
			return fmt.Errorf("coordinator: tested something other than seeds: %s", line)
		}
	}
	if err := scan.Err(); err != nil {
		return err
	}
	if !sawASeed {
		return fmt.Errorf("coordinator: did not test FuzzA seed")
	}
	if !sawBSeed {
		return fmt.Errorf("coordinator: did not test FuzzB seed")
	}
	return nil
}

func checkWorkerLog(r io.Reader) error {
	scan := bufio.NewScanner(r)
	var sawAMutant bool
	for scan.Scan() {
		line := scan.Text()
		if !strings.HasPrefix(line, "FuzzA ") {
			return fmt.Errorf("worker: tested something other than target: %s", line)
		}
		if strings.TrimPrefix(line, "FuzzA ") != `"seed"` {
			sawAMutant = true
		}
	}
	if err := scan.Err(); err != nil && err != bufio.ErrTooLong {
		return err
	}
	if !sawAMutant {
		return fmt.Errorf("worker: did not test any mutants")
	}
	return nil
}
-- check_testdata.go --
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
)

func main() {
	target := os.Args[1]
	numBytes, err := strconv.Atoi(os.Args[2])
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	// Open the file in testdata (there should only be one)
	dir := fmt.Sprintf("testdata/corpus/%s", target)
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	if len(files) != 1 {
		fmt.Fprintf(os.Stderr, "expected one file, got %d", len(files))
		os.Exit(1)
	}
	got, err := ioutil.ReadFile(filepath.Join(dir, files[0].Name()))
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	// Make sure that there were exactly 100 bytes written to the corpus entry
	prefix := []byte("[]byte(")
	i := bytes.Index(got, prefix)
	gotBytes := got[i+len(prefix) : len(got)-1]
	s, err := strconv.Unquote(string(gotBytes))
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	if want, got := numBytes, len(s); want != got {
		fmt.Fprintf(os.Stderr, "want %d bytes, got %d", want, got)
		os.Exit(1)
	}
}
-- mutator_test.go --
package fuzz_test

import (
	"testing"
)

// TODO(katiehockman): re-work this test once we have a better fuzzing engine
// (ie. more mutations, and compiler instrumentation)
func FuzzMutator(f *testing.F) {
	// TODO(katiehockman): simplify this once we can dedupe crashes (e.g.
	// replace map with calls to panic, and simply count the number of crashes
	// that were added to testdata)
	crashes := make(map[string]bool)
	// No seed corpus initiated
	f.Fuzz(func(t *testing.T, b []byte) {
		crashes[string(b)] = true
		if len(crashes) >= 10 {
			panic("mutator found enough unique mutations")
		}
	})
}